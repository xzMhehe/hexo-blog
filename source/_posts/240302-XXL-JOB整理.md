---
title: 【XXL-JOB】总结
date: 2024-03-02 17:40:30
tags:
  - 面试
categories:
  - 面试
keywords:
  - 面试
description: Redis实现验证码加防刷设计
headimg: https://cdn.jsdelivr.net/gh/xzMhehe/StaticFile_CDN/static/img202403021746879.png
thumbnail: https://cdn.jsdelivr.net/gh/xzMhehe/StaticFile_CDN/static/img202403021746879.png
---

# XXL-JOB

![](https://raw.githubusercontent.com/xzMhehe/StaticFile_CDN/main/static/img/mo/20240311094044.png)



## 核心

### 任务触发原理

Xxl-Job最最核心的功能，就是任务触发的原理

任务触发原理分下面5个小点来讲解

- 任务如何触发？
- 快慢线程池的异步触发任务优化
- 如何选择执行器实例？
- 执行器如何去执行任务？
- 任务执行结果的回调



### **任务如何触发？**

调度中心在启动的时候，会开启一个线程，这个线程的作用就是来计算任务触发时机，这里我把这个线程称为**调度线程**

这个调度线程会去查询`xxl_job_info`这张表

这张表存了任务的一些基本信息和任务下一次执行的时间

调度线程会去查询**下一次执行的时间 <= 当前时间 + 5s**的任务

这个5s是XxlJob写死的，被称为预读时间，提前读出来，保证任务能准时触发

举个例子，假设当前时间是`2023-11-29 08:00:10`，这里的查询就会查出下一次任务执行时间在`2023-11-29 08:00:15`之前执行的任务

查询到任务之后，调度线程会去将这些任务根据执行时间划分为三个部分：

- 当前时间已经超过任务下一次执行时间5s以上，也就是需要在`2023-11-29 08:00:05`（不包括05s）之前的执行的任务
- 当前时间已经超过任务下一次执行时间，但是但不足5s，也就是在`2023-11-29 08:00:05`和`2023-11-29 08:00:10`（不包括10s）之间执行的任务
- 还未到触发时间，但是一定是5s内就会触发执行的

对于**第一部分**的已经超过5s以上时间的任务，会根据任务配置的**调度过期策略（页面配置：忽略、立即执行一次）**来选择要不要执行

对于**第二部分**的超时时间在5s以内的任务，就直接立马执行一次，之后如果判断任务下一次执行时间就在5s内，会直接放到一个时间轮里面，等待下一次触发执行

对于**第三部分**任务，由于还没到执行时间，所以不会立马执行，也是直接放到时间轮里面，等待触发执行

当这批任务处理完成之后，不论是前面是什么情况，调度线程都会去重新计算每个任务的下一次触发时间，然后更新`xxl_job_info`这张表的下一次执行时间

到此，一次调度的计算就算完成了

之后调度线程还会继续重复上面的步骤，查任务，调度任务，更新任务下次执行时间，一直死循环下去，这就实现了任务到了执行时间就会触发的功能

这里在任务触发的时候还有一个很有意思的细节

由于调度中心可以是集群的形式，每个调度中心实例都有调度线程，那么如何保证任务在同一时间只会被其中的一个调度中心触发一次？

我猜你第一时间肯定想到分布式锁，但是怎么加呢？

XxlJob实现就比较有意思了，它是基于八股文中常说的通过数据库来实现的分布式锁的

在调度之前，调度线程会尝试执行下面这句sql

```sql
preparedStatement = conn.prepareStatement(  "select * from xxl_job_lock where lock_name = 'schedule_lock' for update" );
preparedStatement.execute();
```

一旦执行成功，说明当前调度中心成功抢到了锁，接下来就可以执行调度任务了

当调度任务执行完之后再去关闭连接，从而释放锁

由于每次执行之前都需要去获取锁，这样就保证在调度中心集群中，同时只有一个调度中心执行调度任务

<img src="https://raw.githubusercontent.com/xzMhehe/StaticFile_CDN/main/static/img/mo/20240311095608.png"/>



### **快慢线程池的异步触发任务优化**

当任务达到了触发条件，并不是由调度线程直接去触发执行器的任务执行

调度线程会将这个触发的任务交给线程池去执行

所以上图中的最后一部分触发任务执行其实是线程池异步去执行的

那么，为什么要使用线程池异步呢？

主要是因为触发任务，需要通过Http接口调用具体的执行器实例去触发任务

<img src="https://raw.githubusercontent.com/xzMhehe/StaticFile_CDN/main/static/img/mo/20240311102143.png"/>

这一过程必然会耗费时间，如果调度线程去做，就会耽误调度的效率

所以就通过异步线程去做，调度线程只负责判断任务是否需要执行

并且，Xxl-Job为了进一步优化任务的触发，将这个触发任务执行的线程池划分成**快线程池**和**慢线程池**两个线程池

```java
public void start(){
    fastTriggerPool = new ThreadPoolExecutor(
            10,
            XxlJobAdminConfig.getAdminConfig().getTriggerPoolFastMax(),
            60L,
            TimeUnit.SECONDS,
            new LinkedBlockingQueue<Runnable>(1000),
            new ThreadFactory() {
                @Override
                public Thread newThread(Runnable r) {
                    return new Thread(r, "xxl-job, admin JobTriggerPoolHelper-fastTriggerPool-" + r.hashCode());
                }
            });

    slowTriggerPool = new ThreadPoolExecutor(
            10,
            XxlJobAdminConfig.getAdminConfig().getTriggerPoolSlowMax(),
            60L,
            TimeUnit.SECONDS,
            new LinkedBlockingQueue<Runnable>(2000),
            new ThreadFactory() {
                @Override
                public Thread newThread(Runnable r) {
                    return new Thread(r, "xxl-job, admin JobTriggerPoolHelper-slowTriggerPool-" + r.hashCode());
                }
            });
}
```

在调用执行器的Http接口触发任务执行的时候，Xxl-Job会去记录每个任务的触发所耗费的时间

注意并不是任务执行时间，只是整个Http请求耗时时间，这是因为执行器执行任务是异步执行的，所以整个时间不包括任务执行时间，这个后面会详细说

当任务一次触发的时间超过500ms，那么这个任务的慢次数就会加1

如果这个任务**一分钟内触发的慢次数超过10次**，接下来就会将触发任务交给慢线程池去执行

所以快慢线程池就是避免那种频繁触发并且每次触发时间还很长的任务阻塞其它任务的触发的情况发生



### **如何选择执行器实例？**

当任务需要触发的时候，调度中心会向执行器发送Http请求，执行器去执行具体的任务

那么问题来了

> 由于一个执行器会有很多实例，那么应该向哪个实例请求？

这其实就跟任务配置时设置的**路由策略**有关了

![image-20240311102727120](C:\Users\ma\AppData\Roaming\Typora\typora-user-images\image-20240311102727120.png)

从图上可以看出xxljob支持多种路由策略

除了分片广播，其余的具体的算法实现都是通过ExecutorRouter的实现类来实现的

<img src="https://raw.githubusercontent.com/xzMhehe/StaticFile_CDN/main/static/img/mo/20240311102807.png"/>



**最不经常使用**（LFU：Least Frequently Used）：Xxl-Job内部会有一个缓存，统计每个任务每个地址的使用次数，每次都选择使用次数最少的地址，这个缓存每隔24小时重置一次

**最近最久未使用**（LRU：Least Recently Used）：将地址存到LinkedHashMap中，它利用LinkedHashMap可以根据元素访问（get/put）顺序来给元素排序的特性，快速找到最近最久未使用（未访问）的节点

**故障转移**：调度中心都会去请求每个执行器，只要能接收到响应，说明执行器正常，那么任务就会交给这个执行器去执行

**忙碌转移**：调度中心也会去请求每个执行器，判断执行器是不是正在执行当前需要执行的任务（任务执行时间过长，导致上一次任务还没执行完，下一次又触发了），如果在执行，说明忙碌，不能用，否则就可以用

**分片广播**：XxlJob给每个执行器分配一个编号，从0开始递增，然后向所有执行器触发任务，告诉每个执行器自己的编号和总共执行器的数据

我们可以通过XxlJobHelper#getShardIndex获取到编号，XxlJobHelper#getShardTotal获取到执行器的总数据量

举个例子，比如你现在需要处理30w条数据，有3个执行器，此时使用分片广播，那么此时可将任务分成3分，每份10w条数据，执行器根据自己的编号选择对应的那份10w数据处理

<img src="https://raw.githubusercontent.com/xzMhehe/StaticFile_CDN/main/static/img/mo/20240311103557.png"/>

### **执行器如何去执行任务？**

> 当执行器接收到调度中心的请求时，会把请求交给ExecutorBizImpl来处理

所以前面提到的故障转移和忙碌转移请求执行器进行判断，最终执行器也是交给ExecutorBizImpl处理的

执行器处理触发请求是这个ExecutorBizImpl的run方法实现的

<img src="https://raw.githubusercontent.com/xzMhehe/StaticFile_CDN/main/static/img/mo/20240311103655.png"/>

当执行器接收到请求，在**正常情况下**，执行器会去为这个任务创建一个单独的线程，这个线程被称为`JobThread`

> 每个任务在触发的时候都有单独的线程去执行，保证不同的任务执行互不影响

之后任务并不是直接交给线程处理的，而是直接放到一个内存队列中，线程直接从队列中获取任务

> 为什么不直接处理，而是交给队列，从队列中获取任务呢？

那就得讲讲不正常的情况了

如果调度中心选择的**执行器实例正在处理定时任务**，那么此时该怎么处理呢？**

这时就跟**阻塞处理策略**有关了

<img src="https://raw.githubusercontent.com/xzMhehe/StaticFile_CDN/main/static/img/mo/20240311104021.png"/>

阻塞处理策略总共有三种：

- 单机串行
- 丢弃后续调度
- 覆盖之前调度

**单机串行**的实现就是将任务放到队列中，由于队列是先进先出的，所以就实现串行，这也是为什么放在队列的原因

**丢弃调度**的实现就是执行器什么事都不用干就可以了，自然而然任务就丢了

**覆盖之前调度**的实现就很暴力了，他是直接重新创建一个JobThread来执行任务，并且尝试打断之前的正在处理任务的JobThread，丢弃之前队列中的任务

> 打断是通过Thread#interrupt方法实现的，所以正在处理的任务还是有可能继续运行，并不是说一打断正在运行的任务就终止了

这里需要注意的一点就是，**阻塞处理策略是对于单个执行器上的任务来生效的，不同执行器实例上的同一个任务是互不影响的**

比如说，有一个任务有两个执行器A和B，路由策略是轮询

任务第一次触发的时候选择了执行器实例A，由于任务执行时间长，任务第二次触发的时候，执行器的路由到了B，此时A的任务还在执行，但是B感知不到A的任务在执行，所以此时B就直接执行了任务

所以此时你配置的什么阻塞处理策略就没什么用了

如果业务中需要保证定时任务同一时间只有一个能运行，需要把任务路由到同一个执行器上，比如路由策略就选择`第一个`



### **任务执行结果的回调**

当任务处理完成之后，执行器会将任务执行的结果发送给调度中心

- JobThread会将任务执行的结果发送到一个内存队列中
- 执行器启动的时候会开启一个处发送任务执行结果的线程：TriggerCallbackThread
- 这个线程会不停地从队列中获取所有的执行结果，将执行结果批量发送给调度中心
- 调用中心接收到请求时，会根据执行的结果修改这次任务的执行状态和进行一些后续的事，比如失败了是否需要重试，是否有子任务需要触发等等

## 基础

**XXL-JOB 是什么？它的主要作用是什么？**

XXL-JOB 是一款分布式任务调度平台，用于解决分布式系统中的定时任务和异步任务调度问题。它提供了任务的注册、调度、执行和监控等功能，能够帮助开发者简化任务调度的复杂性，提高任务执行的准确性和稳定性。

**XXL-JOB 和 Quartz 有什么区别？**
答：XXL-JOB 是在 Quartz 基础上进行的封装和扩展，拥有更简单的任务调度方式、更灵活的任务管理和更强大的任务监控功能。XXL-JOB 提供了分布式任务调度和分片任务等支持，同时具备分布式任务协调和高可用调度中心的能力。

**XXL-JOB 的原理是什么？请描述一下 XXL-JOB 的工作流程。**

答：XXL-JOB 的原理是通过一个任务调度中心和多个任务执行器实现任务的分布式调度和执行。其工作流程如下：

任务调度中心通过任务注册接口将任务信息注册到注册中心。

任务执行器从注册中心获取任务信息，并在指定的时间点执行任务。

任务执行器执行任务后，将执行结果上报给任务调度中心。

任务调度中心根据执行结果进行任务状态的统计和管理。

**XXL-JOB 支持哪些任务调度方式？请分别说明它们的优缺点。**

答：XXL-JOB 支持定时任务、CRON 表达式、API 调用等任务调度方式。

定时任务：可以设置固定的时间间隔来触发任务执行，适用于周期性的任务。

CRON 表达式：可以通过配置 CRON 表达式来触发任务执行，灵活性更高，适用于复杂的时间调度需求。

API 调用：可以通过调用 API 接口来触发任务执行，可以动态灵活地管理任务的执行，适用于需要根据实际业务情况动态触发任务的场景。

**XXL-JOB 的任务触发方式有哪些？如何配置触发方式？**

答：XXL-JOB 的任务触发方式包括手动触发、Cron 触发和调度触发。

手动触发：任务需要手动点击触发执行。

Cron 触发：通过配置 Cron 表达式来触发任务的执行，可以设置定时、周期性的任务执行方式。

调度触发：通过调度中心的任务调度功能自动触发任务的执行，可以根据任务的优先级、依赖关系等进行调度。

触发方式可以通过在任务配置中设置相应的参数来实现。

**XXL-JOB 中的任务执行器是什么？它如何配置和使用？**

答：任务执行器是 XXL-JOB 执行任务的具体实体，是任务的执行者。任务执行器需要独立部署在任务执行的机器上，通过配置连接调度中心的相关信息（如注册中心地址、执行器名称等）来实现与调度中心的通信。任务执行器被调度中心调用时会触发任务的执行。

**XXL-JOB 的任务失败重试是如何实现的？它支持哪些重试策略？**

答：XXL-JOB 支持任务的失败重试机制。在任务配置中可以设置失败重试次数和重试间隔时间，当任务执行失败时，任务调度中心会根据设置的重试次数和间隔时间进行重试操作。支持的重试策略包括固定重试间隔、指数退避重试间隔、随机重试间隔等。

**XXL-JOB 如何实现分片任务？请描述一下分片任务的原理。**

答：XXL-JOB 实现了分片任务的功能，可以将一个任务分片执行，每个执行器运行其中的一片任务。
实现分片任务的原理是：

任务注册时，可以设置分片参数，指定任务分片的总数和当前执行器的分片序号。

在任务执行器获取任务时，通过判断当前执行器的分片序号来决定是否执行该任务。

执行器只会执行当前分片序号符合的任务片段，实现任务的分片执行。

**XXL-JOB 如何实现任务的动态添加和删除？**

答：XXL-JOB 支持动态添加和删除任务。通过调用调度中心提供的 API 接口，可以动态地注册新的任务和删除已注册的任务。添加任务时，需要提供任务的相关信息，如任务名称、任务组、执行器等。删除任务时，需要提供任务的唯一标识，可以通过任务调度中心的任务管理页面获得。

**XXL-JOB 如何监控和管理任务执行情况？**

答：XXL-JOB 提供了丰富的任务监控和管理功能。通过任务调度中心的任务管理页面可以查看已注册和已触发的任务，可以实时监控任务的执行情况和状态，包括任务的执行日志、耗时等信息。此外，XXL-JOB 还提供报警机制，可以根据任务的执行结果进行报警通知。

**XXL-JOB 支持分布式任务调度吗？如果支持，它是如何实现的？**

答：是的，XXL-JOB 支持分布式任务调度。它通过任务调度中心和多个任务执行器实现分布式任务调度。任务调度中心负责任务的注册、调度和监控，而任务执行器负责具体的任务执行。不同的任务执行器可以部署在不同的机器上，实现任务的分布式执行。

**XXL-JOB 是否支持任务的依赖关系？如何配置任务的依赖关系？**
答：是的，XXL-JOB 支持任务的依赖关系。通过在任务配置中设置依赖的任务ID，可以实现任务之间的依赖关系。当依赖的任务执行完毕后，才会触发当前任务的执行。

**XXL-JOB 的任务执行超时如何处理？它支持哪些超时策略？**
答：XXL-JOB 支持任务执行超时处理。在任务配置中可以设置任务的超时时间，如果任务执行超过设置的时间，任务调度中心会根据配置的超时策略进行相应的处理。支持的超时策略包括忽略、丢弃以及失败告警等。

**XXL-JOB 是否支持任务的并行执行？如何配置任务的并行度？**
答：是的，XXL-JOB 支持任务的并行执行。并行度指的是同一任务的多个分片可以同时执行。在任务注册时，可以设置任务的分片总数和当前执行器的分片序号，通过并行执行不同分片来实现任务的并行。

**XXL-JOB 是否支持任务的暂停和恢复？如何实现任务的暂停和恢复？**
答：是的，XXL-JOB 支持任务的暂停和恢复。在任务调度中心的任务管理页面，可以对任务进行暂停和恢复操作。暂停任务后，任务将停止调度和执行；恢复任务后，任务将重新开始调度和执行。

**XXL-JOB 的任务分片策略有哪些？如何选择合适的任务分片策略？**
答：XXL-JOB 提供了四种任务分片策略，包括平均分片、故障转移、一致性HASH和广播。选择合适的任务分片策略需要根据具体的业务需求来决定。比如，平均分片适用于任务执行时间相对均匀的场景，广播适用于任务需要同时在多个执行器上执行的场景等。

**XXL-JOB 是否支持任务的重复执行和跳过已执行的任务？**
答：是的，XXL-JOB 支持任务的重复执行和跳过已执行的任务。通过在任务配置中设置任务的重复执行次数和重复执行间隔，可以控制任务的重复执行。同时，任务调度中心会记录每次任务的执行结果和执行状态，避免重复执行已经成功执行过的任务。

**XXL-JOB 的调度中心和执行器是否支持集群部署？如何实现集群部署？**
答：是的，XXL-JOB 的调度中心和执行器都支持集群部署。调度中心和执行器可以通过配置相同的注册中心地址和注册中心集群模式来实现集群部署。调度中心和执行器会自动进行协调和负载均衡，实现任务的高可用性和分布式执行。

**XXL-JOB 是否支持任务的日志记录和查看？如何查看任务的执行日志？**
答：是的，XXL-JOB 支持任务的日志记录和查看。任务执行时，可以将任务的日志信息记录下来，并通过任务调度中心的任务管理页面查看任务的执行日志。任务执行日志包括任务的执行状态、执行结果和执行日志内容等。

**XXL-JOB 是否支持任务的报警功能？如何配置任务的报警方式？**
答：是的，XXL-JOB 支持任务的报警功能。在任务配置中可以设置任务的报警方式和报警接收人，当任务执行失败或超时时，任务调度中心会发送报警通知给指定的接收人。
