---
title: 【音视频】C++ 多态：派生&虚函数&模板
date: 2022-08-30 15:56:59
tags: 音视频
---

# 继承与派生
>C ++ 是面向对象编程，那么只要面向对象，都会有多态、继承的特性。C++是如何实现继承的呢？

继承（Inheritance）可以理解为一个类从另一个类获取成员变量和成员函数的过程。例如类 B 继承于类 A，那么 B 就拥有 A 的成员变量和成员函数。

在C++中，**派生（Derive）** 和继承是一个概念，只是站的角度不同。继承是儿子接收父亲的产业，派生是父亲把产业传承给儿子。

被继承的类称为父类或基类，继承的类称为子类或派生类。“子类”和“父类”通常放在一起称呼，“基类”和“派生类”通常放在一起称呼。

在C++中继承称为派生类，基类孵化除了派生类,使用：来表示子类继承父类，C++中支持多继承，使用逗号分隔

```cpp
class Parent {
public:
    int name;
protected:
    int code;
private:
    int num;
};

class Parent1 {

};

//C++中，:表示继承，可以多继承逗号分隔
//public/protected/private继承,对于基类起到一些保护机制 默认是private继承
class Child : public Parent, Parent1 {
    void test() {
        //派生类可以访问到public属性和protected属性
        this->name;
        this->code;
    }
};
```

C++中派生类中添加了public 派生、protected派生、private派生,默认是private派生

>class 派生类名:［继承方式］ 基类名{ 派生类新增加的成员 };

```cpp
class Parent {
public:
    int name;
protected:
    int code;
private:
    int num;
};

class Parent1 {

};

//private私有继承
class Child1 : private Parent {
    void test() {
        this->name;
        this->code;
    }
};

//protected继承
class Child2 : protected Parent {
    void test() {
        this->name;
        this->code;
    }
};
```

>public 派生、protected派生、private派生对于，创建的对象调用父类的属性和方法起到了限制和保护的作用

```cpp
    Child child;
    child.name;//public继承。调用者可以访问到父类公有属性，私有属性访问不到的

    Child1 child1;
//    child1.name;//private继承.调用者访问不到父类公有属性和私有属性

    Child2 child2;
//    child2.name;//protected继承，调用者访问不到父类公有属性和私有属性
```

# 虚函数
**重点！！！** C++的继承和java中的继承存在的不同点: 基类成员函数和派生类成员函数不构成重载

>基类成员和派生类成员的名字一样时会造成遮蔽，这句话对于成员变量很好理解，对于成员函数要引起注意，不管函数的参数如何，只要名字一样就会造成遮蔽。换句话说，基类成员函数和派生类成员函数不会构成重载，如果派生类有同名函数，那么就会遮蔽基类中的所有同名函数，不管它们的参数是否一样。​


## 父类代码如下
```cpp
#include <cstring>
#include <iostream>

using namespace std;

class Person {
protected:
    char *str;
public:
    Person(char *str) {
        if (str != NULL) {
            this->str = new char[strlen(str) + 1];
            strcpy(this->str, str);
        } else {
            this->str = NULL;
        }
        cout << "parent" << endl;
    }

    Person(const Person &p) {
        cout << "copy parent" << endl;
    }

    void printC() {
        cout << "parent printC" << endl;
    }

    ~Person() {
//        if (str != NULL) {
//            delete[] str;//如果调用了这个方法只会调用一次析构函数
//        }
//        cout << "parent destroy" << endl;
    }

};
```

子类继承父类，并且调用父类的构造函数, 通过：来调用父类的构造函数
```cpp
//子类
class CTest : public Person {
public:
    //调用父类的构造方法
    CTest(char *str) : Person(str) {
        cout << "child" << endl;
    }

    void printC() {
        cout << "child printC" << endl;
    }

    ~CTest() {
        cout << "child destroy " << endl;
    }
};
```
在C++中和Java的不同在于如下代码：只要是父类的指针都是调用的父类的方法，哪怕子类对象直接赋值给父类，也会调用父类的方法，而不会调用子类的方法。

```cpp
int main() {
    Person person = CTest("jake");

    person.printC();//parent printC

    cout << "-----------" << endl;
    Person *p = NULL;
    CTest c1("123");
    p = &c1;
    c1.printC();//child printC
    p->printC();//parent printC 为什么会调用的是parent的方法呢？

    return 0;
}
```

```bash
parent
child
copy parent
child destroy 
parent printC
-----------
parent
child
child printC
parent printC
child destroy 
```

哪怕通过指针传递和引用传递，只要使用的父类都会调用父类的方法

```cpp
//通过指针传递只会调用父类的方法，不会调用子类的方法
void howToPaint(Person *p) {
    p->printC();
}

//通过引用类型，只会调用父类的方法，不会调用子类的方法
void howToPaint1(Person &p) {
    p.printC();
}
```

```cpp
cout << "---------" << endl;
howToPaint(p);//parent printC
howToPaint(&c1);//parent printC

cout << "-------" << endl;
Person p1("123");
//都是父类的方法
howToPaint1(p1);//parent printC
howToPaint1(c1);//parent printC

cout << "--------" << endl;
CTest c2("123");
Person p2 = c2;//会不会调用父类的拷贝函数呢？ copy parent 会进行调用
```


```bash
---------
parent printC
parent printC
-------
parent
parent printC
parent printC
--------
parent
child
copy parent
child destroy 
child destroy 
```

这是为什么呢？

>C++ 中会按照函数表的顺序进行调用，很显然父类的函数是在子类函数的前面的

`那么如何调用到子类的方法呢`？`C ++提供了虚函数的方式，虚函数也是实现多态的关键。​`

虚函数与纯虚函数，纯虚函数在java 中 abstract == 纯虚函数

>实际开发中，一旦我们自己定义了析构函数，就是希望在对象销毁时用它来进行清理工作，比如释放内存、关闭文件等，如果这个类又是一个基类，那么我们就必须将该析构函数声明为虚函数，否则就有内存泄露的风险。也就是说，大部分情况下都应该将基类的析构函数声明为虚函数。


>包含纯虚函数的类称为抽象类（Abstract Class）。之所以说它抽象，是因为它无法实例化，也就是无法创建对象。原因很明显，纯虚函数没有函数体，不是完整的函数，无法调用，也无法为其分配内存空间。

抽象类通常是作为基类，让派生类去实现纯虚函数。派生类必须实现纯虚函数才能被实例化。

- 一个纯虚函数就可以使类成为抽象基类，但是抽象基类中除了包含纯虚函数外，还可以包含其它的成员函数（虚函数或普通函数）和成员变量。

- 只有类中的虚函数才能被声明为纯虚函数，普通成员函数和顶层函数均不能声明为纯虚函数。

- 基类的析构函数必须声明为虚函数。

```cpp
#include <iostream>

using namespace std;

class Person {
public:
    //增加了一个虚函数表的指针
    virtual void look() {//虚函数 子类可以覆写的函数
        cout << "virtual look" << endl;
    }

    virtual void speak() {

    };//纯虚函数 必须要让子类实现的
    //基类的析构函数必须声明为虚函数
    virtual ~Person() {
        cout << "~Person" << endl;
    }
};

class Child : public Person {
public:
    void speak() override {//子类实现纯虚函数
        cout << "child speak" << endl;
    }

    void look() override {
        cout << "child look" << endl;
        Person::look();//访问父类的方法
    }

    ~Child() {
        cout << "~Child" << endl;
    }
};

int main() {
    Person *person = new Child();//必须通过指针的方式，不同通过栈的方式去派生抽象
    person->speak();//child speak
    person->look();//child look

    Person p;
    cout << sizeof(p) << endl;//8 这就表明了虚函数是有一个虚函数表，增加一个指针*vtable，指向了虚函数表
    //下面代码来证明
    typedef void (*func)(void);
    func fun = NULL;
    cout << (int *) &p << endl;//指向函数的首地址 0x16ee1efa8
    cout << (int *) *(int *) &p << endl;//函数的地址 0xfe40a0
    fun = (func) *((int *) *(int *) &p);
    fun();//virtual look
    return 0;
}

/**
 * child speak
 * child look
 * virtual look
 * ~Child
 * ~Person
 */
```

```bash
child speak
child look
virtual look
8
0x16ee1efa8
0xfe40a0
```


# 模板

