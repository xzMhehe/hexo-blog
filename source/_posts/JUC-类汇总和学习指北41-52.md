---
title: JUC - 类汇总和学习打卡第四天
date: 2021-06-24 09:36:59
tags:
  - Java
  - 面经
categories:
  - Java
keywords:
  - Java
description: Java
headimg: https://cdn.jsdelivr.net/gh/xzMhehe/StaticFile_CDN/static/img/20210625075357.png
thumbnail: https://cdn.jsdelivr.net/gh/xzMhehe/StaticFile_CDN/static/img/20210625075357.png
---
## 41、tryLock 和 lock 和 lockInterruptibly 的区别

1. tryLock 能获得锁就返回 true，不能就立即返回 false， tryLock(long timeout,TimeUnit unit)，可以增加时间限制，如果超过该时间段还没获得锁，返回 false

2. lock 能获得锁就返回 true，不能的话一直等待获得锁

3. lock 和 lockInterruptibly，如果两个线程分别执行这两个方法，但此时中断这两个线程，lock 不会抛出异常，而 lockInterruptibly 会抛出异常。

## 42、Semaphore 信号量
Semaphore 是一种基于计数的信号量。它可以设定一个阈值，基于此，多个线程竞争获取许可信 号，做完自己的申请后归还，超过阈值后，线程申请许可信号将会被阻塞。 Semaphore 可以用来 构建一些对象池，资源池之类的， 比如数据库连接池

实现互斥锁（计数器为 1）

我们也可以创建计数为 1 的 Semaphore，将其作为一种类似互斥锁的机制，这也叫二元信号量， 表示两种互斥状态。

代码实现
```java
public class MSemaphore {

    public void test() {
        // 创建一个计数阈值为 5 的信号量对象
        // 只能 5 个线程同时访问
        Semaphore semp = new Semaphore(5);
        try { // 申请许可
            semp.acquire();
            try {
                // 业务逻辑
            } catch (Exception e) {
            } finally {
                // 释放许可
                semp.release();
            }
        } catch (InterruptedException e) {
        }
    }

}
```

## 43、Semaphore 与 ReentrantLock 区别
Semaphore 基本能完成 ReentrantLock 的所有工作，使用方法也与之类似，通过 acquire()与
release()方法来获得和释放临界资源。经实测， Semaphone.acquire()方法默认为可响应中断锁， 与 ReentrantLock.lockInterruptibly()作用效果一致，也就是说在等待临界资源的过程中可以被
Thread.interrupt()方法中断。

此外， Semaphore 也实现了可轮询的锁请求与定时锁的功能，除了方法名 tryAcquire 与 tryLock 不同，其使用方法与 ReentrantLock 几乎一致。 Semaphore 也提供了公平与非公平锁的机制，也 可在构造函数中进行设定。

Semaphore 的锁释放操作也由手动进行，因此与 ReentrantLock 一样，为避免线程因抛出异常而 无法正常释放锁的情况发生，释放锁的操作也必须在 ﬁnally 代码块中完成。

## 44、可重入锁（递归锁）
本文里面讲的是广义上的可重入锁，而不是单指 JAVA 下的 ReentrantLock。 `可重入锁`，也叫做`递归锁`，指的是同一线程 外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，但不受影响。在 JAVA 环境下 `ReentrantLock` 和 `synchronized` 都是 可重入锁。

## 45、公平锁与非公平锁
公平锁（Fair）        
加锁前检查是否有排队等待的线程，优先排队等待的线程，先来先得

非公平锁（Nonfair）          
加锁时不考虑排队等待问题，直接尝试获取锁，获取不到自动到队尾等待

1. 非公平锁性能比公平锁高 5~10 倍，因为公平锁需要在多核的情况下维护一个队列

2. Java 中的 synchronized 是非公平锁， ReentrantLock 默认的 lock()方法采用的是非公平锁。

## 46、ReadWriteLock 读写锁
为了提高性能， Java 提供了读写锁，在读的地方使用读锁，在写的地方使用写锁，灵活控制，如 果没有写锁的情况下，读是无阻塞的,在一定程度上提高了程序的执行效率。 读写锁分为读锁和写 锁，多个读锁不互斥，读锁与写锁互斥，这是由 jvm 自己控制的，你只要上好相应的锁即可。

**读锁**
如果你的代码只读数据，可以很多人同时读，但不能同时写，那就上读锁

**写锁**
如果你的代码修改数据，只能有一个人在写，且不能同时读取，那就上写锁。总之，读的时候上 读锁，写的时候上写锁！

`Java 中 读 写 锁 有 个 接 口 java.util.concurrent.locks.ReadWriteLock ， 也 有 具 体 的 实 现 ReentrantReadWriteLock。`

## 47、共享锁和独占锁
java 并发包提供的加锁模式分为独占锁和共享锁。

独占锁            
独占锁模式下，每次只能有一个线程能持有锁， ReentrantLock 就是以独占方式实现的互斥锁。 独占锁是一种悲观保守的加锁策略，它避免了读/读冲突，如果某个只读线程获取锁，则其他读线 程都只能等待，这种情况下就限制了不必要的并发性，因为读操作并不会影响数据的一致性。

共享锁          
共享锁则允许多个线程同时获取锁，并发访问 共享资源，如： ReadWriteLock。 共享锁则是一种 乐观锁，它放宽了加锁策略，允许多个执行读操作的线程同时访问共享资源。

1. AQS 的内部类 Node 定义了两个常量 SHARED 和 EXCLUSIVE，他们分别标识 AQS 队列中等待线程的锁获取模式。

2. java 的并发包中提供了 ReadWriteLock，读-写锁。它允许一个资源可以被多个读操作访问， 或者被一个 写操作访问，但两者不能同时进行。

## 48、重量级锁（Mutex Lock）
Synchronized 是通过对象内部的一个叫做监视器锁（monitor）来实现的。但是监视器锁本质又是依赖 于底层的操作系统的 Mutex Lock 来实现的。

而操作系统实现线程之间的切换这就需要从用户态转换到核心态，这个成本非常高，状态之间的转换需 要相对比较长的时间，这就是为什么Synchronized 效率低的原因。

因此， 这种依赖于操作系统 Mutex Lock 所实现的锁我们称之为“重量级锁” 。 JDK 中对 Synchronized 做的种种优化，其核心都是为了减少这种重量级锁的使用。

JDK1.6 以后，为了减少获得锁和释放锁所带来的性能消耗，提高性能，引入了“`轻量级锁`”和“`偏向锁`”。

## 49、轻量级锁
锁的状态总共有`四种`：`无锁状态`、`偏向锁`、`轻量级锁`和`重量级锁`。

锁升级        
随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁（但是锁的升级是单向的， 也就是说只能从低到高升级，不会出现锁的降级）。

“轻量级” 是相对于使用操作系统互斥量来实现的传统锁而言的。但是，首先需要强调一点的是， 轻量级锁并不是用来代替重量级锁的，它的本意是在没有多线程竞争的前提下，减少传统的重量 级锁使用产生的性能消耗。

在解释轻量级锁的执行过程之前， 先明白一点，轻量级锁所适应的场景是线程交替执行同步块的情况， 如果存在同一时间访问同一锁的情况，就会导致轻量级锁膨胀为重量级锁



## 50、偏向锁
Hotspot 的作者经过以往的研究发现大多数情况下锁不仅不存在多线程竞争，而且总是由同一线程多次 获得。 偏向锁的目的是在某个线程获得锁之后，消除这个线程锁重入（CAS）的开销，看起来让这个线 程得到了偏护。

引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取 及释放依赖多次 CAS 原子指令， 而偏向锁只需要在置换ThreadID 的时候依赖一次 CAS 原子指令（由 于一旦出现多线程竞争的情况就必须撤销偏向锁，所以偏向锁的撤销操作的性能损耗必须小于节省下来 的 CAS 原子指令的性能消耗）。

上面说过， 轻量级锁是为了在线程交替执行同步块时提高性能， 而偏向锁则是在只有一个线程执行同 步块时进一步提高性能

## 51、分段锁
分段锁也并非一种实际的锁，而是一种思想 ConcurrentHashMap 是学习分段锁的最好实践

**减少锁持有时间**          
只用在有线程安全要求的程序上加锁

**减小锁粒度**           
将大对象（这个对象可能会被很多线程访问），拆成小对象，大大增加并行度，降低锁竞争。 降低了锁的竞争，偏向锁，轻量级锁成功率才会提高。最最典型的减小锁粒度的案例就是 ConcurrentHashMap。

**锁分离**       
最常见的锁分离就是读写锁 ReadWriteLock，根据功能进行分离成`读锁`和`写锁`，这样`读读不互斥`，`读写互斥`，`写写互斥`，即`保证了线程安全`，又`提高了性能`，具体也请查看[高并发 Java 五] JDK 并发包 读写分离思想可以延伸，只要操作互不影响，锁就可以分离。比如 `LinkedBlockingQueue` 从头部取出，从尾部放数据


**锁粗化**      
通常情况下，为了保证多线程间的有效并发，会要求每个线程持有锁的时间尽量短，即在使用完 公共资源后，应该立即释放锁。但是，凡事都有一个度， 如果对同一个锁不停的进行请求、同步 和释放，其本身也会消耗系统宝贵的资源，反而不利于性能的优化 。

**锁消除**       
锁消除是在编译器级别的事情。 在即时编译器时，如果发现不可能被共享的对象，则可以消除这 些对象的锁操作，多数是因为程序员编码不规范引起。

参考： https://www.jianshu.com/p/39628e1180a9







