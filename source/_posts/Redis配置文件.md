---
title: Redis配置文件
date: 2021-01-10 19:17:32
tags:
- Redis
categories: 
- Redis
---


### Redis.config详解
启动的时候通过配置文件来启动(windows 10)

行家有没有, 出手就知道
### 单位
```bash
## 1k => 1000 bytes
## 1kb => 1024 bytes
## 1m => 1000000 bytes
## 1mb => 1024*1024 bytes
## 1g => 1000000000 bytes
## 1gb => 1024*1024*1024 bytes
#
## units are case insensitive so 1GB 1Gb 1gB are all the same.
```

- 配置文件 unit 单位对大小写不敏感

### 可以包含其他配置文件INCLUDES
```bash
################################### INCLUDES ###################################

## Include one or more other config files here.  This is useful if you
## have a standard template that goes to all Redis servers but also need
## to customize a few per-server settings.  Include files can include
## other files, so use this wisely.
#
## Notice option "include" won't be rewritten by command "CONFIG REWRITE"
## from admin or Redis Sentinel. Since Redis always uses the last processed
## line as value of a configuration directive, you'd better put includes
## at the beginning of this file to avoid overwriting config change at runtime.
#
## If instead you are interested in using includes to override configuration
## options, it is better to use include as the last line.
#
## include .\path\to\local.conf
## include c:\path\to\other.conf
```

就像Spring import include


### 网络NETWORK

```bash
################################### NETWORK #####################################

## By default, if no "bind" configuration directive is specified, Redis listens
## for connections from all the network interfaces available on the server.
## It is possible to listen to just one or multiple selected interfaces using
## the "bind" configuration directive, followed by one or more IP addresses.
#
## Examples:
#
## bind 192.168.1.100 10.0.0.1
## bind 127.0.0.1 ::1
#
## ~~~ WARNING ~~~ If the computer running Redis is directly exposed to the
## internet, binding to all the interfaces is dangerous and will expose the
## instance to everybody on the internet. So by default we uncomment the
## following bind directive, that will force Redis to listen only into
## the IPv4 lookback interface address (this means Redis will be able to
## accept connections only from clients running into the same computer it
## is running).
#
## IF YOU ARE SURE YOU WANT YOUR INSTANCE TO LISTEN TO ALL THE INTERFACES
## JUST COMMENT THE FOLLOWING LINE.
## ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
bind 127.0.0.1 ## 绑定的ip

## Protected mode is a layer of security protection, in order to avoid that
## Redis instances left open on the internet are accessed and exploited.
#
## When protected mode is on and if:
#
## 1) The server is not binding explicitly to a set of addresses using the
##    "bind" directive.
## 2) No password is configured.
#
## The server only accepts connections from clients connecting from the
## IPv4 and IPv6 loopback addresses 127.0.0.1 and ::1, and from Unix domain
## sockets.
#
## By default protected mode is enabled. You should disable it only if
## you are sure you want clients from other hosts to connect to Redis
## even if no authentication is configured, nor a specific set of interfaces
## are explicitly listed using the "bind" directive.
protected-mode yes  ## 受保护模式, 开启, 保证安全性

## Accept connections on the specified port, default is 6379 (IANA #815344).
## If port 0 is specified Redis will not listen on a TCP socket.
port 6379         ## 端口设置

## TCP listen() backlog.
#
## In high requests-per-second environments you need an high backlog in order
## to avoid slow clients connections issues. Note that the Linux kernel
## will silently truncate it to the value of /proc/sys/net/core/somaxconn so
## make sure to raise both the value of somaxconn and tcp_max_syn_backlog
## in order to get the desired effect.
tcp-backlog 511

## Unix socket.
#
## Specify the path for the Unix socket that will be used to listen for
## incoming connections. There is no default, so Redis will not listen
## on a unix socket when not specified.
#
## unixsocket /tmp/redis.sock
## unixsocketperm 700

## Close the connection after a client is idle for N seconds (0 to disable)
timeout 0

## TCP keepalive.
#
## If non-zero, use SO_KEEPALIVE to send TCP ACKs to clients in absence
## of communication. This is useful for two reasons:
#
## 1) Detect dead peers.
## 2) Take the connection alive from the point of view of network
##    equipment in the middle.
#
## On Linux, the specified value (in seconds) is the period used to send ACKs.
## Note that to close the connection the double of the time is needed.
## On other kernels the period depends on the kernel configuration.
#
## A reasonable value for this option is 60 seconds.
tcp-keepalive 0
```

- bind 127.0.0.1 ## 绑定的ip
- protected-mode yes  ## 受保护模式, 开启, 保证安全性
- port 6379         ## 端口设置

### 通用配置GENERAL

```bash
################################## GENERAL #####################################

## By default Redis does not run as a daemon. Use 'yes' if you need it.
## Note that Redis will write a pid file in /var/run/redis.pid when daemonized.
## NOT SUPPORTED ON WINDOWS daemonize no
daemonize yes

## If you run Redis from upstart or systemd, Redis can interact with your
## supervision tree. Options:
##   supervised no      - no supervision interaction
##   supervised upstart - signal upstart by putting Redis into SIGSTOP mode
##   supervised systemd - signal systemd by writing READY=1 to $NOTIFY_SOCKET
##   supervised auto    - detect upstart or systemd method based on
##                        UPSTART_JOB or NOTIFY_SOCKET environment variables
## Note: these supervision methods only signal "process is ready."
##       They do not enable continuous liveness pings back to your supervisor.
## NOT SUPPORTED ON WINDOWS supervised no
supervised no

## If a pid file is specified, Redis writes it where specified at startup
## and removes it at exit.
#
## When the server runs non daemonized, no pid file is created if none is
## specified in the configuration. When the server is daemonized, the pid file
## is used even if not specified, defaulting to "/var/run/redis.pid".
#
## Creating a pid file is best effort: if Redis is not able to create it
## nothing bad happens, the server will start and run normally.
## NOT SUPPORTED ON WINDOWS pidfile /var/run/redis.pid
pidfile /var/run/redis.pid

## Specify the server verbosity level.
## This can be one of:
## debug (a lot of information, useful for development/testing)
## verbose (many rarely useful info, but not a mess like the debug level)
## notice (moderately verbose, what you want in production probably)
## warning (only very important / critical messages are logged)
loglevel notice  ## 生产环境

## Specify the log file name. Also 'stdout' can be used to force
## Redis to log on the standard output.
logfile ""         ## 生成的文件名

## To enable logging to the Windows EventLog, just set 'syslog-enabled' to
## yes, and optionally update the other syslog parameters to suit your needs.
## If Redis is installed and launched as a Windows Service, this will
## automatically be enabled.
## syslog-enabled no

## Specify the source name of the events in the Windows Application log.
## syslog-ident redis

## Set the number of databases. The default database is DB 0, you can select
## a different one on a per-connection basis using SELECT <dbid> where
## dbid is a number between 0 and 'databases'-1
databases 16            ## 数据库的数量， 默认三是16个
```

- daemonize no    ## 以守护进程的方式运行, 默认是 no , 我们需要自己开启为 yes    
- pidfile /var/run/redis.pid    ## 如果以后台的方式运行, 我们就需要指定一个 pid 进行文件
- loglevel notice       ## 日志级别  （debug、 verbose、 notice、 warning）
- logfile ""         ## 生成的文件名
- always-show-logo  yes     ## 是否总是显示logo


### 快照SNAPSHOTTING
持久化, 在规定时间内, 执行多少次操作, 则会持久化到文件  .rdb   .aof

```bash
################################# SNAPSHOTTING  ################################
#
## Save the DB on disk:
#
##   save <seconds> <changes>
#
##   Will save the DB if both the given number of seconds and the given
##   number of write operations against the DB occurred.
#
##   In the example below the behaviour will be to save:
##   after 900 sec (15 min) if at least 1 key changed
##   after 300 sec (5 min) if at least 10 keys changed
##   after 60 sec if at least 10000 keys changed
#
##   Note: you can disable saving completely by commenting out all "save" lines.
#
##   It is also possible to remove all the previously configured save
##   points by adding a save directive with a single empty string argument
##   like in the following example:
#
##   save ""

save 900 1              ## 持久化规则, redis 是内存数据库, 不持久化的话数据就会丢
save 300 10
save 60 10000

## By default Redis will stop accepting writes if RDB snapshots are enabled
## (at least one save point) and the latest background save failed.
## This will make the user aware (in a hard way) that data is not persisting
## on disk properly, otherwise chances are that no one will notice and some
## disaster will happen.
#
## If the background saving process will start working again Redis will
## automatically allow writes again.
#
## However if you have setup your proper monitoring of the Redis server
## and persistence, you may want to disable this feature so that Redis will
## continue to work as usual even if there are problems with disk,
## permissions, and so forth.
stop-writes-on-bgsave-error yes         ## 持久化出错, 是否仍进行工作

## Compress string objects using LZF when dump .rdb databases?
## For default that's set to 'yes' as it's almost always a win.
## If you want to save some CPU in the saving child set it to 'no' but
## the dataset will likely be bigger if you have compressible values or keys.
rdbcompression yes          ## 是否压缩 rdb 文件 (需要消耗 cpu 资源)

## Since version 5 of RDB a CRC64 checksum is placed at the end of the file.
## This makes the format more resistant to corruption but there is a performance
## hit to pay (around 10%) when saving and loading RDB files, so you can disable it
## for maximum performances.
#
## RDB files created with checksum disabled have a checksum of zero that will
## tell the loading code to skip the check.
rdbchecksum yes            ## 是否校验 rdb 文件 

## The filename where to dump the DB
dbfilename dump.rdb

## The working directory.
#
## The DB will be written inside this directory, with the filename specified
## above using the 'dbfilename' configuration directive.
## 
## The Append Only File will also be created inside this directory.
## 
## Note that you must specify a directory here, not a file name.
dir ./

```

内存数据库, 如果没有持久化, 那么数据断电及失(可自定义设置自己所需要的)
- save 900 1              ## 900秒内如果至少有一个 key 进行修改, 我们就进行持久化操作
save 300 10               ## 300秒内如果至少有十个 key 进行修改, 我们就进行持久化操作
save 60 10000             ## 60秒内如果至少有一万个 key 进行修改, 我们就进行持久化操作(高并发)

- stop-writes-on-bgsave-error yes         ## 持久化出错, 是否仍进行工作
- rdbcompression yes          ## 是否压缩 rdb 文件 (需要消耗 cpu 资源)
- rdbchecksum yes            ## 保存 rdb 文件的时候, 进行错误检查校验
- dir ./                      ## rdb 文件保存的目录


### 复制REPLICATION
主从复制

### 安全SECURITY
安全, 默认是没有密码的.

```bash
################################### SECURITY ###################################

## Require clients to issue AUTH <PASSWORD> before processing any other
## commands.  This might be useful in environments in which you do not trust
## others with access to the host running redis-server.
#
## This should stay commented out for backward compatibility and because most
## people do not need auth (e.g. they run their own servers).
## 
## Warning: since Redis is pretty fast an outside user can try up to
## 150k passwords per second against a good box. This means that you should
## use a very strong password otherwise it will be very easy to break.
#
## requirepass foobared          ## 设置密码
requirepass 123456
## Command renaming.
#
## It is possible to change the name of dangerous commands in a shared
## environment. For instance the CONFIG command may be renamed into something
## hard to guess so that it will still be available for internal-use tools
## but not available for general clients.
#
## Example:
#
## rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52
#
## It is also possible to completely kill a command by renaming it into
## an empty string:
#
## rename-command CONFIG ""
#
## Please note that changing the name of commands that are logged into the
## AOF file or transmitted to slaves may cause problems.
```

- requirepass 123456            ## 手动设置
- 命令行设置                     ## config set requirepass "123456"
- 若已设置密码则需要登录 命令  auth 123456
- 登录成功 获取用户密码      config get requirepass    


### 限制 LIMITS
CLIENTS
```bash
#################################### LIMITS ####################################

## Set the max number of connected clients at the same time. By default
## this limit is set to 10000 clients, however if the Redis server is not
## able to configure the process file limit to allow for the specified limit
## the max number of allowed clients is set to the current file limit
## minus 32 (as Redis reserves a few file descriptors for internal uses).
#
## Once the limit is reached Redis will close all the new connections sending
## an error 'max number of clients reached'.
#
## maxclients 10000                  ## 设置能链接上 redis 最大客户端 数量

## If Redis is to be used as an in-memory-only cache without any kind of
## persistence, then the fork() mechanism used by the background AOF/RDB
## persistence is unnecessary. As an optimization, all persistence can be
## turned off in the Windows version of Redis. This will redirect heap
## allocations to the system heap allocator, and disable commands that would
## otherwise cause fork() operations: BGSAVE and BGREWRITEAOF.
## This flag may not be combined with any of the other flags that configure
## AOF and RDB operations.
## persistence-available [(yes)|no]

## Don't use more memory than the specified amount of bytes.
## When the memory limit is reached Redis will try to remove keys
## according to the eviction policy selected (see maxmemory-policy).
#
## If Redis can't remove keys according to the policy, or if the policy is
## set to 'noeviction', Redis will start to reply with errors to commands
## that would use more memory, like SET, LPUSH, and so on, and will continue
## to reply to read-only commands like GET.
#
## This option is usually useful when using Redis as an LRU cache, or to set
## a hard memory limit for an instance (using the 'noeviction' policy).
#
## WARNING: If you have slaves attached to an instance with maxmemory on,
## the size of the output buffers needed to feed the slaves are subtracted
## from the used memory count, so that network problems / resyncs will
## not trigger a loop where keys are evicted, and in turn the output
## buffer of slaves is full with DELs of keys evicted triggering the deletion
## of more keys, and so forth until the database is completely emptied.
#
## In short... if you have slaves attached it is suggested that you set a lower
## limit for maxmemory so that there is some free RAM on the system for slave
## output buffers (but this is not needed if the policy is 'noeviction').
#
## WARNING: not setting maxmemory will cause Redis to terminate with an
## out-of-memory exception if the heap limit is reached.
#
## NOTE: since Redis uses the system paging file to allocate the heap memory,
## the Working Set memory usage showed by the Windows Task Manager or by other
## tools such as ProcessExplorer will not always be accurate. For example, right
## after a background save of the RDB or the AOF files, the working set value
## may drop significantly. In order to check the correct amount of memory used
## by the redis-server to store the data, use the INFO client command. The INFO
## command shows only the memory used to store the redis data, not the extra
## memory used by the Windows process for its own requirements. Th3 extra amount
## of memory not reported by the INFO command can be calculated subtracting the
## Peak Working Set reported by the Windows Task Manager and the used_memory_peak
## reported by the INFO command.
#
## maxmemory <bytes>                     ## redis 配置最大内存容量

## MAXMEMORY POLICY: how Redis will select what to remove when maxmemory
## is reached. You can select among five behaviors:
## 
## volatile-lru -> remove the key with an expire set using an LRU algorithm
## allkeys-lru -> remove any key according to the LRU algorithm
## volatile-random -> remove a random key with an expire set
## allkeys-random -> remove a random key, any key
## volatile-ttl -> remove the key with the nearest expire time (minor TTL)
## noeviction -> don't expire at all, just return an error on write operations
## 
## Note: with any of the above policies, Redis will return an error on write
##       operations, when there are no suitable keys for eviction.
#
##       At the date of writing these commands are: set setnx setex append
##       incr decr rpush lpush rpushx lpushx linsert lset rpoplpush sadd
##       sinter sinterstore sunion sunionstore sdiff sdiffstore zadd zincrby
##       zunionstore zinterstore hset hsetnx hmset hincrby incrby decrby
##       getset mset msetnx exec sort
#
## The default is:
#
## maxmemory-policy noeviction

## LRU and minimal TTL algorithms are not precise algorithms but approximated
## algorithms (in order to save memory), so you can select as well the sample
## size to check. For instance for default Redis will check three keys and
## pick the one that was used less recently, you can change the sample size
## using the following configuration directive.
#
## maxmemory-samples 3
```
-  maxclients 10000                  ## 设置能链接上 redis 最大客户端 数量
-  maxmemory <bytes>                     ## redis 配置最大内存容量
-  maxmemory-policy noeviction          ## 内存达到上限处理策略          （移除一些过期的 key; 报错）
>1、volatile-lru：只对设置了过期时间的key进行LRU（默认值） 
>2、allkeys-lru ： 删除lru算法的key   
>3、volatile-random：随机删除即将过期key   
>4、allkeys-random：随机删除   
>5、volatile-ttl ： 删除即将过期的   
>6、noeviction ： 永不过期，返回错误


### APPEND ONLY 模式
AOF
```bash
############################### APPEND ONLY MODE ###############################

## By default Redis asynchronously dumps the dataset on disk. This mode is
## good enough in many applications, but an issue with the Redis process or
## a power outage may result into a few minutes of writes lost (depending on
## the configured save points).
#
## The Append Only File is an alternative persistence mode that provides
## much better durability. For instance using the default data fsync policy
## (see later in the config file) Redis can lose just one second of writes in a
## dramatic event like a server power outage, or a single write if something
## wrong with the Redis process itself happens, but the operating system is
## still running correctly.
#
## AOF and RDB persistence can be enabled at the same time without problems.
## If the AOF is enabled on startup Redis will load the AOF, that is the file
## with the better durability guarantees.
#
## Please check http://redis.io/topics/persistence for more information.

appendonly no           ## 默认是不开启

## The name of the append only file (default: "appendonly.aof")
appendfilename "appendonly.aof"         ## 持久化的文件的名字

## The fsync() call tells the Operating System to actually write data on disk
## instead of waiting for more data in the output buffer. Some OS will really flush
## data on disk, some other OS will just try to do it ASAP.
#
## Redis supports three different modes:
#
## no: don't fsync, just let the OS flush the data when it wants. Faster.
## always: fsync after every write to the append only log . Slow, Safest.
## everysec: fsync only one time every second. Compromise.
#
## The default is "everysec", as that's usually the right compromise between
## speed and data safety. It's up to you to understand if you can relax this to
## "no" that will let the operating system flush the output buffer when
## it wants, for better performances (but if you can live with the idea of
## some data loss consider the default persistence mode that's snapshotting),
## or on the contrary, use "always" that's very slow but a bit safer than
## everysec.
#
## More details please check the following article:
## http://antirez.com/post/redis-persistence-demystified.html
#
## If unsure, use "everysec".

## appendfsync always
appendfsync everysec        
## appendfsync no

## When the AOF fsync policy is set to always or everysec, and a background
## saving process (a background save or AOF log background rewriting) is
## performing a lot of I/O against the disk, in some Linux configurations
## Redis may block too long on the fsync() call. Note that there is no fix for
## this currently, as even performing fsync in a different thread will block
## our synchronous write(2) call.
#
## In order to mitigate this problem it's possible to use the following option
## that will prevent fsync() from being called in the main process while a
## BGSAVE or BGREWRITEAOF is in progress.
#
## This means that while another child is saving, the durability of Redis is
## the same as "appendfsync none". In practical terms, this means that it is
## possible to lose up to 30 seconds of log in the worst scenario (with the
## default Linux settings).
## 
## If you have latency problems turn this to "yes". Otherwise leave it as
## "no" that is the safest pick from the point of view of durability.
no-appendfsync-on-rewrite no

## Automatic rewrite of the append only file.
## Redis is able to automatically rewrite the log file implicitly calling
## BGREWRITEAOF when the AOF log size grows by the specified percentage.
## 
## This is how it works: Redis remembers the size of the AOF file after the
## latest rewrite (if no rewrite has happened since the restart, the size of
## the AOF at startup is used).
#
## This base size is compared to the current size. If the current size is
## bigger than the specified percentage, the rewrite is triggered. Also
## you need to specify a minimal size for the AOF file to be rewritten, this
## is useful to avoid rewriting the AOF file even if the percentage increase
## is reached but it is still pretty small.
#
## Specify a percentage of zero in order to disable the automatic AOF
## rewrite feature.

auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb

## An AOF file may be found to be truncated at the end during the Redis
## startup process, when the AOF data gets loaded back into memory.
## This may happen when the system where Redis is running
## crashes, especially when an ext4 filesystem is mounted without the
## data=ordered option (however this can't happen when Redis itself
## crashes or aborts but the operating system still works correctly).
#
## Redis can either exit with an error when this happens, or load as much
## data as possible (the default now) and start if the AOF file is found
## to be truncated at the end. The following option controls this behavior.
#
## If aof-load-truncated is set to yes, a truncated AOF file is loaded and
## the Redis server starts emitting a log to inform the user of the event.
## Otherwise if the option is set to no, the server aborts with an error
## and refuses to start. When the option is set to no, the user requires
## to fix the AOF file using the "redis-check-aof" utility before to restart
## the server.
#
## Note that if the AOF file will be found to be corrupted in the middle
## the server will still exit with an error. This option only applies when
## Redis will try to read more data from the AOF file but not enough bytes
## will be found.
aof-load-truncated yes
```

- appendonly no           ## 默认是不开启 aof 模式的, 默认使用的是 rdb 方式持久化, 在大部分所有情况下, rdb 完全够用
- appendfilename "appendonly.aof"         ## 持久化的文件的名字          
- appendfsync everysec          ## 每秒执行一次  sync 可能会丢失 1s 的数据
## appendfsync no            ## 不执行 sync 这个时候操作系统自己同步数据 速度最快
## appendfsync always        ## 每次修改都会 sync 消耗性能

>文章已上传gitee https://gitee.com/codingce/hexo-blog   
>项目地址: https://github.com/xzMhehe/codingce-java

