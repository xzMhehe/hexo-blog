---
title: 【软考】2020 软考整理
date: 2023-09-26 10:14:06
tags:
  - 软考
categories:
  - 软考
keywords:
  - 软考
description: 软考
headimg: https://raw.githubusercontent.com/xzMhehe/StaticFile_CDN/main/static/img/mo/20230926160123.png
thumbnail: https://raw.githubusercontent.com/xzMhehe/StaticFile_CDN/main/static/img/mo/20230926160123.png
---


## 上午选择题
### 第 1 题
以下关于信息特性的描述中，错误的是（ ）。
>(A) 信息必须依附于某种载体进行传输
(B) 通过感官的识别属于信息间接识别
\(C\) 通过各种测试手段的识别属于信息间接识别
(D) 信息在特定的范围内有效


B ~~通过感官的识别属于信息间接识别~~。信息是可以识别的，不同的信息源有不同的识别方法。识别分为直接识别和间接识别，直接识别是指通过感官的识别，间接识别是指通过各种测试手段的识别。很明显B选项“通过感官的识别属于信息间接识别”的说法是错误的。其他选项说法正确，都是关于信息的准确描述。

### 第 2 题
信息系统进入使用阶段后，主要任务是（ ）。
>(A) 进行信息系统开发与测试
(B) 进行信息系统需求分析
\(C\) 对信息系统进行管理和维护
(D) 对信息系统数据库进行设计

C `对信息系统进行管理和维护`。系统交付使用后的主要任务就是运行管理和维护，而选项A、B、D都是信息系统开发阶段需要做的工作。

### 第 3 题
5G网络技术具有（ ）的特点。
>(A) 低带宽、低时延
(B) 低带宽、高时延
\(C\) 高带宽、低时延
(D) 高带宽、高时延

C `高带宽、低时延`。5G技术（第五代移动通信技术）具有高带宽、低时延的特点，可用于大数据量高速传输，实时响应以满足远程医疗、自动驾驶等需要。

### 第 4 题
企业采用云计算模式部署信息系统所具有的优势中不包括（ ）。
>(A) 企业的全部数据、科研和技术都放到网上，以利共享
(B) 全面优化业务流程，加速培育新产品、新模式、新业态
\(C\) 从软件、平台、网络等各方面，加快两化深度融合步伐
(D) 有效整合优化资源，重塑生产组织方式，实现协同创新

A ~~企业的全部数据、科研和技术都放到网上，以利共享~~。企业采用云计算模式部署信息系统时，一般都会考虑将哪些数据放在公有云或私有云上，如何保护企业的商业秘密以及企业员工的隐私，需要考虑尚在研发的未成熟的技术数据如何保存、保护和管理。


### 第 5 题
（ ）是正确的统一资源地址（URL）。
>(A) stmp: \www.xd.edu.cn/index.html
(B) stmp://www.xd.edu.cn/index.html
\(C\) http: \www.xd.edu.cn/index.html
(D) http://www.xd.edu.cn/index.html

D URL的基本结构为“协议名://服务器名（或IP地址）/路径和文件名”。最常用的协议名为http（或htpps），对比发现D选项书写正确。

### 第 6 题
计算机中最基本的单位基准时间是（ ）。
>(A) 时钟周期
(B) 指令周期
\(C\) 总线周期
(D) CPU周期

A `时钟周期`又叫作`振荡周期`、`节拍周期`，定义为时钟晶振频率的倒数。时钟周期是计算机中最基本的、最小的时间单位。在一个时钟周期内，CPU仅完成一个最基本的动作。

指令周期是指取出并完成一条指令所需的时间，一般由若干个机器周期组成。

在计算机中，为了便于管理，常把一条指令的执行过程划分为若干个阶段，每一阶段完成一项工作。例如，取指令、存储器读、存储器写等，每一项工作称为一个基本操作，完成一个基本操作所需要的时间称为机器周期（也称为CPU周期）。

通常把CPU通过总线对微处理器外部（存储器或I/O端口）进行一次访问所需要的时间称为一个总线周期。

综上所述，正确的答案为A选项。

### 第 7 题
CPU主要由运算器、控制器组成，下列不属于运算器的部件是（ ）。
>(A) 算术逻运算单元
(B) 程序计数器
\(C\) 累加器
(D) 状态寄存器

B ~~程序计数器~~。CPU主要由`运算器`、`控制器(Control Unit,CU)`、`寄存器组`和`内部总线`组成。

运算器(ALU)主要完成算术运算和逻辑运算，实现对数据的加工与处理。包括`算术和逻辑运算单元（ALU）`、`累加器(AC)`、`状态寄存器(PSW)`、`寄存器组`及`多路转换器`等逻辑部件。

控制器的主要功能是从内存中取出指令，并指出下一条指令在内存中的位置，将取出的指令送入指令寄存器，启动指令译码器对指令进行分析，最后发出相应的控制信号和定时信息，控制和协调计算机的各个部件有条不紊地工作，以完成指令所规定的操作。控制器主要由程序计数器(PC)、 指令寄存器(IR)、 指令译码器、状态寄存器(PSW)、时序产生器和微操作信号发生器等组成。

### 第 8 题
将操作数包含在指令中的寻址方式称为（ ）。
>(A) 直接寻址
(B) 相对寻址
\(C\) 间接寻址
(D) 立即寻址

D **立即寻址**。若`操作数就包含在指令中`，则是`立即寻址`。

若`操作数存放在内存单元中`，指令中直接给出操作数所在存储单元的地址，则是`直接寻址`。

间接寻址是相对于直接寻址而言的，指令地址字段的形式地址不是操作数的真正地址，而是操作数地址的指示器。

若`操作数存放在某一寄存器中`，指令中给出存放操作数的寄存器名，则是`寄存器寻址`。

若`操作数存放在内存单元中`，`操作数所在存储单元的地址在某个寄存器中`，则是`寄存器间接寻址`。

### 第 9 题
以下关于中断的叙述中，错误的是（ ）。
>(A) 电源掉电属于CPU必须无条件响应的不可屏蔽中断
(B) 打印机中断属于不可屏蔽的内部中断
\(C\) 程序运行错误也可能引发中断
(D) CPU可通过指令限制某些设备发出中断请求

中断是这样一个过程：在CPU执行程序的过程中，由于某一个外部的或CPU内部事件的发生，使CPU暂时中止正在执行的程序，转去处理这一事件， 当事件处理完毕后又回到原先被中止的程序，接着中止前的状态继续向下执行。这一过程就称为中断。

引起中断的事件就称为中断源。若中断是由CPU内部发生的事件引起的，这类中断源就称为内部中断源;若中断是由CPU外部的事件引起的，则称为外部中断源。

中断包括软件中断（不可屏蔽）和硬件中断。软中断为内核触发机制引起，模拟硬件中断。硬件中断又分为外部中断（可屏蔽）和内部中断（不可屏蔽）。外部中断为一般外设请求；内部中断包括硬件出错(掉电、校验、传输)和运算出错（非法数据、地址、越界、溢出等）。

打印机中断属于可屏蔽的外部中断。

### 第 10 题
在计算机系统中，通常可以（ ），以提高计算机访问磁盘的效率。
>(A) 利用存储管理软件定期对内存进行碎片整理
(B) 利用磁盘碎片整理程序定期对磁盘进行碎片整理
\(C\) 利用系统资源管理器定期对ROM进行碎片整理
(D) 利用磁盘碎片整理程序定期对磁盘数据进行压缩

B 利用磁盘碎片整理程序定期对磁盘进行碎片整理。

本题考查计算机系统性能方面的基础知识。

文件在磁盘上一般是以块（或扇区）的形式存储的。有的文件可能存储在一个连续的区域内，有的文件则被分割成若干个“片”存储在磁盘中不连续的多个区域。这种情况对文件的完整性没有影响，但由于文件过于分散，将增加计算机读盘的时间，从而降低了计算机的效率。磁盘碎片整理程序可以在整个磁盘系统范围内对文件重新安排，将各个文件碎片在保证文件完整性的前提下转换到连续的存储区内，提高对文件的读取速度。

### 第 11 题
显示器的（ ）是指显示器屏幕上同一点最亮时（白色）与最暗时（黑色）的亮度的比值。
>(A) 对比度
(B) 点距
\(C\) 分辨率
(D) 刷新频率

A **对比度**。本题考查计算机系统方面的基本常识。

显示器的对比度指的是显示器屏幕上同一点最亮时（白色）与最暗时（黑色）的亮度的比值。高的对比度意味着相对较高的亮度和呈现颜色的艳丽程度。品质优异的LCD显示器面板和优秀的背光源亮度，两者合理配合就能获得色彩饱满明亮清晰的画面。

### 第 12 题
使用图像扫描仪以300DPI的分辨率扫描一幅3英寸X3英寸的图片，可以得到（ ）像素的数字图像。
>(A) 100X100
(B) 300X300
\(C\) 600X600
(D) 900X900

本题考查多媒体的基础知识。

分辨率为300DPI（每英寸）时，3英寸为3X300=900像素。

### 第 13 题
采用直线和曲线等元素来描述的图是（ ）。
>(A) 点阵图
(B) 矢量图
\(C\) 位图
(D) 灰度图

B 矢量图。矢量图是根据几何特性、通过多个对象的组合生成图形，矢量可以是一个点或一条线。矢量文件中的图形元素称为对象。每个对象都是一个自成一体的实体，它具有颜色、形状、轮廓、大小和屏幕位置等属性。

位图也称为点阵图、像素图等，构成位图的最小单位是像素，位图就是由像素阵列的排列来实现其显示效果的，每个像素有自己的颜色信息，在对位图图像进行编辑操作的时候，可操作的对象是每个像素,可以改变图像的色相、饱和度、明度，从而改变图像的显示效果。对位图进行缩放时会失真。

### 第 14 题
两个申请人分别就相同内容的计算机程序的发明创造，先后向专利行政部门提出申请，则（ ）。
>(A) 两个申请人都可以获得专利申请权
(B) 先申请人可以获得专利申请权
\(C\) 先使用人可以获得专利申请权
(D) 先发明人可以获得专利申请权

B 先申请人可以获得专利申请权。对于专利权而言，`遵循的是谁先申请谁拥有的原则`，`如果同时申请，就需要协商进行处理`。

### 第 15 题
利用（ ）可以对软件的技术信息、经营信息提供保护。
>(A) 著作权
(B) 专利权
\(C\) 商标权
(D) 商业秘密权

D 商业秘密权。商业秘密权是指当事人可以依法对商业秘密享有占有、使用、收益和处分的权利。商业秘密权具有知识产权的本质特征，是对创造性成果给予保护的权利形态，`可以对软件的技术信息、经营信息提供保护`。

### 第 16 题
在需要保护的信息资产中，（ ）是最重要的。
>(A) 软件
(B) 硬件
\(C\) 数据
(D) 环境

C 数据。本题考查信息安全的基础知识。

在信息资产中，软件、硬件及环境都具有可重构性，`数据则存在不可完全恢复的可能性`，因此是最重要的。

### 第 17 题
身份认证是证实需要认证的客户真实身份与其所声称的身份是否相符的验证过程。目前，计算机及网络系统中常用的身份认证技术主要有用户名/密码方式、智能卡认证、动态口令、生物特征认证等。生物特征认证不包括（ ）。
>(A) 指纹
(B) 面部识别
\(C\) 虹膜
(D) 击键特征

D ~~击键特征~~。本题考查计算机系统的基础知识。

生物特征识别技术是指通过计算机利用人体所固有的生理特征（指纹、虹膜、面相、DNA等）或行为特征（步态、声音、笔迹等）来进行个人身份鉴定的技术。


### 第 18 题
从对信息的破坏性上看，网络攻击可以分为被动攻击和主动攻击。以下属于被动攻击的是（ ）。
>(A) 伪造
(B) 流量分析
\(C\) 拒绝服务
(D) 中间人攻击

B **流量分析**。网络攻击是指针对计算机信息系统、基础设施、计算机网络或个人计算机设备的，任何类型的进攻动作。对于计算机和计算机网络来说，破坏、揭露、修改、使软件或服务失去功能、在没有得到授权的情况下偷取或访问计算机系统的数据，都会被视为对计算机和计算机网络的攻击。

主动攻击会导致某些数据流的篡改和虚假数据流的产生。这类攻击可分为篡改、伪造消息数据和终端（拒绝服务）。

被动攻击中的攻击者不对数据信息做任何修改，而是在`未经用户同意和认可的情况下`，`攻击者获得了信息或相关数据`。通常包括`窃听`、`流量分析`、`破解弱加密的数据流`等攻击方式。

### 第 19 题
二进制序列1011011可用十六进制形式表示为（ ）。
>(A) 5B
(B) 3B
\(C\) B6
(D) BB

A 5B。本题考查计算机系统中的数据表示的基础知识。

二进制与十六进制的转换是将每四位二进制转换成一位十六进制。

所以二进制1011011转换成十六进制为5B

### 第 20 题
设码长为8，原码10000000所表示的十进制整数的值为（ ）。
>(A) -128
(B) -0
\(C\) 1
(D) 128

B -0。本题考查计算机系统中的数据表示的基础知识。

原码、反码和补码表示是数值数据的三种基本的编码方法，对于正数，三种编码表示是相同的，不同之处在于负数的表示。

码长为8即用8位二进制形式来表示数值，其中最左边的位是符号位，0表示是正数，1表示是负数，剩余的7位表示数值部分，原码表示的规则是直接表示出数值的绝对值。本题中`10000000的最高位为1`，`表示是负数`。数值部分为0，即绝对值为0的数值。在原码表示中，0由于符号部分不同占用00000000和10000000两个编码。

### 第 21 题
设有两个浮点数，其阶码分别为E1和E2，当这两个浮点数相乘时，运算结果的阶码E为（ ）。
>(A) E1、E2中的较小者
(B) E1、E2中的较大者
\(C\) E1+E2 的值
(D) E1XE2的值

C E1+E2 的值。本题考查计算机系统中的数据运算的基础知识。

在机器中表示一个浮点数时，一是要给出尾数，用定点小数形式表示，尾数部分给出有效数字的位数，因而决定了浮点数的表示精度。二是要给出指数，用整数形式表示，常称为阶码，阶码指明小数点在数据中的位置，因而决定了浮点数的表示范围。

例如，浮点数X=1101.0101，Y=10.0111，按照浮点格式（忽略标准格式要求）表示为X=0.11010101X2^4，Y=0.100111X2^2。若进行加减运算，需要先对阶，也就是在阶码一致的情况下对尾数部分进行加减运算；若进行乘除运算，则不要求阶码一致。 相乘时阶码部分为两个浮点数的阶码相加，尾数部分直接相乘，之后再按照规格化等要求进行处理。


### 第 22 题
在定点二进制运算中，减法运算是通过（ ）来实现的。
>(A) 原码表示的二进制加法
(B) 补码表示的二进制加法
\(C\)原码表示的二进制减法
(D) 补码表示的二进制减法

B 本题考查计算机系统中的数据运算的基础知识。

用原码表示数据时，是在数值位部分表示出相应数值的绝对值。如果符号位相同，则减法运算是用绝对值较大者减去绝对值；若符号位不同，则减法运算实质是对两者的绝对值部分进行相加运算处理。

用补码表示数据时，可以将减法转化为加法过程，运算时符号位和数值位用相同的规则处理，统一进行二进制相加运算即可。




### 第 23 题
Windows操作系统通常将系统文件保存在（ ）。
>(A) “MyDrivers”文件或“update"文件中
(B) “MyDrivers"文件夹或“update"文件夹中
\(C\) “Windows"文件或“Program Files”文件中
(D) “Windows”文件夹和“Program Files”文件夹中

D。本题考查Windows操作系统方面的基础知识。

在操作系统中，文件是保存在文件夹（根目录或子目录）中的，故选项A、选项C是错误的。Windows系统中，系统文件是计算机上运行Windows所必需的文件。系统文件通常保存在“Windows"文件夹或“Program Files” 文件夹中，可见选项B也是错误的。根据排除法，正确选项为D。
注意:默认情况下，系统文件是隐藏的，以避免将其意外修改或删除。

### 第 24 题
嵌入式操作系统的特点之一是可定制，这里的可定制是指（ ）。
>(A) 系统构件、模块和体系结构必须达到应有的可靠性
(B) 对过程控制、数据采集、传输等需要迅速响应
\(C\) 在不同的微处理器平台上，能针对硬件变化进行结构与功能上的配置
(D) 采用硬件抽象层和板级支撑包的底层设计技术

C。本题考查嵌入式操作系统的基本概念。

嵌入式操作系统的主要特点包括微型化、可定制、实时性、可靠性和易移植性。其中，可定制是指从减少成本和缩短研发周期考虑，要求嵌入式操作系统能运行在不同的微处理器平台上，能针对硬件变化进行结构与功能上的配置，以满足不同应用需要。

### 第 25 题
假设有6个进程共享一个互斥段N，如果最多允许3个进程同时访问互斥段N，那么利用PV操作时，所用信号量S的变化范围为（ ）；若信号量S的当前值为-1，则表示系统中有（ ）个正在等待该资源的进程。
>(A) 0~6
(B) -1~5
\(C\) -2~4
(D) -3~3

>(A) 0
(B) 1
\(C\) 2
(D) 3

D B。本题考查操作系统进程管理同步与互斥方面的基础知识。

系统中有6个进程共享一个互斥段N，如果最多允许2个进程同时进入N,那么信号量S的初值应设为3。假设6个进程依次进入N，那么当第一个进程进入N时，信号量S减1，等于2；当第二个进程进入N时，信号量S减1，等于1；当第三个进程进入N时，信号量S减1,等于0；当第四个进程进入N时，信号量S减1，等于-1；当第五个进程进入N时，信号量S减1，等于-2；当第六个进程进入N时，信号量S减1，等于-3。可见，信号量的变化范围是-3~3。

根据PV操作定义，当信号量的值小于0时，其绝对值表示等待资源的进程数，所以试题中，信号量S的当前值为-1，则表示系统中有1个进程请求资源得不到满足。

### 第 26 题
假设分页存储管理系统中，地址用32个二进制位表示，其中页号占12位，页内地址占20位。若系统以字节编址，则该系统（ ）。
>(A) 页面大小为2MB，共有4096个页面
(B) 页面大小为2MB，共有1024个页面
\(C\) 页面大小为1MB，共有4096个页面
(D) 页面大小为1MB，共有1024个页面

C。本题考查操作系统分页存储管理系统的基础知识。

试题的正确答案为C。因为，根据题意可知页内地址的长度为二进制20位，220=2^10X2^10=1024X1024=1024KB=1MB，所以该系统页的大小为1MB。又因为，页号的地址的长度为二进制12位，2^12=4096，所以该系统共有4096个页面。

### 第 27 题
针对C语言源程序进行编译的过程，下面说法中正确的是（ ）。
>(A) 需对未定义的变量报告错误
(B) 需判断变量的值是否正确
\(C\) 需计算循环语句的执行次数
(D) 需判断循环条件是否正确

A。本题考查计算机系统的基础知识。

对C语言源程序进行翻译的过程包括预处理、编译、链接等过程，编译过程中需要进行词法分析、语法分析、语义分析、中间代码生成、优化和目标代码生成，以及出错管理和符号表管理等。程序的语义包括静态语义和动态语义，编译过程中可以处理静态语义，动态语义在运行时处理。未定义的变量可在编译时报告，关于变量的值、循环条件的值及循环体语句的执行次数等都属于动态语义。

### 第 28 题
以下关于高级程序设计语言的编译和解释的叙述中，正确的是（ ）。
>(A) 编译方式和解释方式都是先进行语法分析再进行语义分析
(B) 编译方式下先进行语义分析再进行语法分析
\(C\) 解释方式下先进行语义分析再进行语法分析
(D) 编译方式和解释方式都是先进行语义分析再进行语法分析

A。本题考查计算机系统的基础知识。

用高级程序设计语言或汇编语言编写的程序称为源程序，源程序不能直接在计算机上执行。如果源程序是用汇编语言编写的，则需要一个称为汇编程序的翻译程序将其翻译成目标程序后才能执行。如果源程序是用某种高级语言编写的，则需要对应的解释程序或编译程序对其进行翻译，然后在机器上运行。

解释程序也称为解释器，它可以直接解释执行源程序，或者将源程序翻译成某种中间表示形式后再加以执行；而编译程序（编译器）则首先将源程序翻译成目标语言程序，将目标程序与库函数链接后形成可执行程序，然后在计算机上运行可执行程序。
无论是编译还是解释方式，都需要对源程序依次进行`词法分析`、`语法分析`、`语义分析`。

### 第 29 题
关于下图所示的有限自动机M（A是初态、C是终态）的叙述中，正确的是（ ）。
![](https://raw.githubusercontent.com/xzMhehe/StaticFile_CDN/main/static/img/mo/20231009100714.png)

(A) M是确定的有限自动机，可识别1001
(B) M是确定的有限自动机，可识别1010
\(C\) M是不确定的有限自动机，可识别1010
(D) M是不确定的有限自动机，可识别1001

A。本题考查程序语言翻译的基础知识。

首先关于其是否是确定有限自动机和不确定的有限自动机的判断。

就是看关于该结点的路径相同数字是否到达不同的结点，如果相同数字不同结点就是不确定的有限自动机。很明显图示未存在这样的情况，属于确定的有限自动机；能够识别的字符串必须要达到终点，故1001是能够被识别的，而1010不能够被识别，综合答案选择A选项。

### 第 30 题
C语言程序中如果定义了名字都为a的全局变量和局部变量，则（ ）。
>(A) 编译时报告名字a重复定义错误
(B) 对a的引用固定指向全局变量
\(C\) 对a的引用固定指向局部变量
(D) 在局部变量a的作用域内屏蔽全局变量a

D。本题考查程序语言的基础知识。

通常来说，一段程序代码中所用到的名字并不总是有效可用的，而限定这个名字的可用性的代码范围就是这个名字的作用域，包括静态作用域原则和最近嵌套原则。静态作用域原则是指编译时就可以确定名字的作用域，也可以说，仅从静态读程序可确定名字的作用域。当作用域形成嵌套关系时，如块包含在函数中，函数包含在文件中，则最接近引用处定义的名字有效。从名字被定义的代码位置开始，局部变量若是定义在复合语句中，则仅在其所定义的复合语句中可引用;若是定义在函数中，则在其所定义的函数中可引用。而全局变量则可在多个函数或多个程序语言中被引用。

如果有相同名字的全局变量和局部变量a，则在引用名字a的代码所在作用域中，局部变量a的作用域内屏蔽全局变量a。

### 第 31 题
在某C程序中有下面的类型和变量定义（设字符型数据占1字节,整型数据占4字节），则运行时系统为变量rec分配的空间大小为（ ）。
![](https://raw.githubusercontent.com/xzMhehe/StaticFile_CDN/main/static/img/mo/20231007182241.png)

>(A) 1字节
(B) 4字节
\(C\)5字节
(D) 8字节

B **共用体变量的大小取决于其所需存储空间最大的成员，最大的整形字符4字节。**

### 第 32 题
对于某C程序中的如下语句（ ）。
![](https://raw.githubusercontent.com/xzMhehe/StaticFile_CDN/main/static/img/mo/20231007182545.png)
>(A) 运行时输出true
(B) 编译时报告错误
\(C\)运行时输出false
(D) 运行时报告异常

### 第 33 题
某C程序中含有下面语句，其执行后，tmp的值是（ ）。
![](https://raw.githubusercontent.com/xzMhehe/StaticFile_CDN/main/static/img/mo/20231009100952.png)

>(A) 0
(B) 2
\(C\) 4
(D) 8

D。本题考查C程序语言的基础知识。

逗号表达式的求值过程为：从左至右依次处理由逗号运算符“,”连接的运算对象，先对左侧的表达式求值，结果丢弃，最后保留右侧表达式的值。对tmp的赋值结果来自逗号表达式(x=2,y=4,z=8)，该表达式最后的结果为8，因此tmp的值为8。

### 第 34 题
函数main()、f()的定义如下所示。调用函数f()时，采用引用调用方式(all by reference)，从函数f()返回后，main()中x的值为（ ）。
![](https://raw.githubusercontent.com/xzMhehe/StaticFile_CDN/main/static/img/mo/20231009101057.png)

>(A) 1
(B) 2
\(C\) 4
(D) 5

A。本题考查程序语言的基础知识。

引用调用是指在被调用函数中，形参是实参的引用（或别名），在被调用函数中对形参的操作即是对实参的操作，因此结束调用后对实参进行修改的结果得以保留。在本例中，形参a即main中的实参x，在f中a为本地变量x减去1，结果为1，main中的x被修改为1，因此最后输出为1。
在具体实现中，引用参数的实现是将实参的地址传递给形参，借助指针实现对实参变量的访问。
### 第 35 题
栈是后进先出的线性数据结构，其基本操作不包括（ ）。
>(A) 从栈底删除元素
(B) 从栈顶弹出元素
\(C\) 判断是否为空栈
(D) 在栈顶加入元素

A。本题考查数据结构的基础知识。

栈的基本操作有入栈、出栈、取栈顶及判断栈是否为空。入栈和出栈是指在栈顶加入及删除元素，取栈顶操作仅读取栈顶元素的值而不删除元素。从栈底删除元素不是应用栈时的基本操作。

### 第 36 题
对于采用头指针作为唯一标识的单链表， 其优点是（ ）。
>(A) 可以随机访问表中的任一元素
(B) 可以快速在表头插入元素
\(C\) 可以快速在表尾插入元素
(D) 可从任意位置出发遍历链表

B。本题考查数据结构的基础知识。
![](https://raw.githubusercontent.com/xzMhehe/StaticFile_CDN/main/static/img/mo/20231009101358.png)


### 第 37 题
下图所示为一个二叉排序树（二叉查找树），其先序遍历序列为（ ）。
![](https://raw.githubusercontent.com/xzMhehe/StaticFile_CDN/main/static/img/mo/20231009101625.png)

>(A) 12, 15, 18, 23, 29, 34, 56, 71
(B) 12, 18, 15, 34, 29, 71, 56, 23
\(C\) 23, 15, 56, 12, 18, 29, 71, 34
(D) 23, 15, 12, 18, 56, 29, 34, 71

D。本题考查数据结构的基础知识。

先序遍历二叉树的操作定义如下：若二叉树为空，则进行空操作，否则访问根结点、先序遍历根的左子树、先序遍历根的右子树。
题中所示二叉树的先序遍历序列为23, 15, 12, 18, 56, 29, 34, 71。

对二叉排序树进行中序遍历得到树中结点关键字的有序序列。


### 第 38 题
将一个三对角矩阵A[1..100, 1..100]进行压缩存储，方法是按行优先方式，将三对角中的元素存入一维数组B\[1..298\]中。在这种存储方式下，设元素A\[56,55\]存储在B\[k\]，则k为（ ）。

>(A) 164
(B) 165
(C) 166
(D) 167

B。本题考查数据结构的基础知识。

n对角矩阵是一种特殊矩阵，矩阵中的非零元素都分布在主对角线及临近主对角线的次对角线上，三对角矩阵如下图所示。
![](https://raw.githubusercontent.com/xzMhehe/StaticFile_CDN/main/static/img/mo/20231009101910.png)
按行排列，元素A[56,55]之前有164个元素((56-1)X3-1+(55-56+1))，因此该元素对应着B[165]。

### 第 39 题
对于一棵结点数为n(n>1)的完全二叉树，从根结点这一层开始，按照从上往下、从左到右的顺序，把结点依次存储在数组A[1..n]中。设某结点在数组A中的位置为i，且它有右孩子，则该右孩子结点在A中的位置是（ ）。

>(A) 2i-1
(B) 2i
(C) 2i+1
(D) log2(i+1)

C。本题考查数据结构的基础知识。

在一个高度为h的完全二叉树中，除了第h层（即最后一层），其余各层都是满的。在第h层上的结点必须从左到右依次放置，不能留空，例如，高度为3的完全二叉树有以下4种，如下图所示，其中图（a）是完全二叉树也是满二叉树。

![](https://raw.githubusercontent.com/xzMhehe/StaticFile_CDN/main/static/img/mo/20231010150452.png)
对完全二叉树中的结点从1开始编号，自上而下、自左至右依次进行。即根结点的编号为1，其左孩子结点编号为2，右孩子结点编号为3，以此类推，编号为i的结点的左孩子（存在时）编号为2i、右孩子（存在时）编号为2i+1。

### 第 40 题
以下关于字符串的叙述中，正确的是（ ）。
>(A) 字符串是长度受限的线性表
(B) 字符串不能采用链表存储
(C) 字符串是一种非线性数据结构
(D) 空字符串的长度为0

D。本题考查数据结构的基础知识。

字符串是一种线性表，其特殊性在于元素为字符，同时具有其特别的基本运算，如串比较、求子串、串连接等。

选项A是错误的，字符串的长度不受限制。

选项B是错误的，字符串可采用链表存储，只是这种存储方式大多数情况下不利于支持串的基本运算。

选项C是错误的，字符串属于线性数据结构。

对于含有n个元素的关键码序列{k1, k2, ..., kn}，当且仅当满足关系ki≤k2i且ki≤k2i+1时称为小根堆。下面关键码序列中，（ ）是 小根堆。
![](https://raw.githubusercontent.com/xzMhehe/StaticFile_CDN/main/static/img/mo/20231010150632.png)

>(A) 131, 158, 288, 325, 763, 522, 451, 617
(B) 131, 325, 451, 617, 522, 288, 158, 763
(C) 763, 617, 325, 522, 451, 288, 131, 158
(D) 763, 451, 522, 617, 131, 288, 325, 158

A。本题考查数据结构的基础知识。

根据堆的定义，将序列表示为完全二叉树更容易判定相应元素之间的大小关系是否满足堆的定义。

选项A的序列如下图所示，k1(131)、k2(158)、k3(288)显然满足k1≤k2且k1≤k3，k2(158)、k4(325)、k5(763)同样满足k2最小，同理可得知k3(288)、k6(522)、k7(451)中k3最小，k4(325)、k8(617)中k4最小(k9不存在，不予考虑)，因此，该序列满足小根堆的定义。
![](https://raw.githubusercontent.com/xzMhehe/StaticFile_CDN/main/static/img/mo/20231010150937.png)

对于选项B，将其表示在一棵完全二叉树，如下图所示：k1(131)、k2(325)、k3(451)满足k1≤k2且k1≤k3，k2(325)、k4(617)、k5(522)中k2最小，符合小根堆定义，而k3(451)、k6(288)、k7(158)中则是k3最大，不符合小根堆的定义，因此整个序列不是小根堆。

![](https://raw.githubusercontent.com/xzMhehe/StaticFile_CDN/main/static/img/mo/20231010151006.png)

对于选项C和D可采用相同方式加以判断，可得知其不是小根堆。

### 第 41 题
以下关于图的存储结构的叙述中，正确的是（ ）。
>(A) 有向图应采用邻接矩阵存储，无向图应采用邻接表存储
(B) 无向图应采用邻接矩阵存储，有向图应采用邻接表存储:
(C) 稠密图适合采用邻接矩阵存储，稀疏图适合采用邻接表存储
(D) 稀疏图适合采用邻接矩阵存储，稠密图适合采用邻接表存储

C。本题考查数据结构的基础知识。

邻接矩阵和邻接表是图的两种基本存储结构，矩阵的每行和每列都对应图中的一个顶点，矩阵元素则表示行对应的顶点和列对应的顶点之间是否有边（弧），如下图所示。
![](https://raw.githubusercontent.com/xzMhehe/StaticFile_CDN/main/static/img/mo/20231010151114.png)

邻接链表是为图的每个顶点建立一个单链表，第i个单链表中的结点表示依附于顶点vi的边（对于有向图是以vi为尾的弧）。邻接链表中的结点有表结点和表头结点两种类型，例如下图（a）所示无向图的邻接表如下图（b）所示。

![](https://raw.githubusercontent.com/xzMhehe/StaticFile_CDN/main/static/img/mo/20231010151133.png)

### 第 42 题
在面向对象程序设计语言中，对象之间通过（ ）方式进行通信。（ ）不是面向对象程序设计语言必须提供的机制。
>(A) 继承
(B) 引用
(C) 消息传递
(D) 多态

>(A) 支持被封装的对象
(B) 支持类与实例的概念
(C) 支持继承和多态
(D) 支持通过指针进行引用


### 第 43 题

### 第 44 题


### 第 45 题


### 第 46 题

### 第 47 题


### 第 48 题


### 第 49 题

### 第 50 题


### 第 51 题


### 第 52 题

### 第 53 题


### 第 54 题


### 第 55 题

### 第 56 题


### 第 57 题


### 第 58 题

### 第 59 题


### 第 60 题


### 第 61 题

### 第 62 题


### 第 63 题


### 第 64 题

### 第 65 题


### 第 66 题


### 第 67 题

### 第 68 题


### 第 69 题


### 第 70 题

## 下午机试
### 第1题
阅读以下说明和流程图，填写流程图中的空缺，将解答填入答题纸的对应栏内。

**【说明】**

下面流程图所示算法的功能是：在一个二进制位串中，求出连续的“1”构成的所有子串的最大长度M。例如，对于二进制位串0100111011110，M=4。

该算法中，将长度为n的二进制位串的各位数字，按照从左到右的顺序依次存放在数组A[1..n]。在对各个二进制位扫描的过程中，变量L动态地记录连续“1”的个数。

**【流程图】**

![](https://raw.githubusercontent.com/xzMhehe/StaticFile_CDN/main/static/img/mo/20231012130739.png)


注：循环开始框内应给出循环控制变量的初值和终值，默认递增值为1。

**试题难度**：一般

**知识点**：流程图>流程图

**试题答案**：
>(1) 0
(2) L+1或等效形式
(3) 0→L或等效形式
(4) L>M或L≥M或等效形式
(5) M

本流程图采用的算法是对二进制位串从左到右进行逐位判断，并累计连续遇到数字1的个数L，再以动态地得到当前L的最大值M。
初始时，L和M都应该是0，故初值为0，因此，流程图的空(1)处应填0。

接着开始对i=1,2,…,n循环，依次判断二进制数位A\[i\]是否为1。如果A\[i\]=1，就应该将L增1，即执行L+1→L，因此流程图的空(2)处应填L+1；如果A\[i\]=0，则应该将数字1的累计长度L清0，重新开始累计，因此，流程图的空(3)处应填0→L。

当遇到数字1进行累计L后，应将L与现行的擂台值M进行比较。如果L>M，则显然应该以新的L值代替原来的M值，即执行L→M；如果L\<M，则不能更新M值；如果L=M，则可以更新也可以不更新M值，对计算结果没有影响。为此，流程图的空(4)处可填L\>M或L≥M (填前者更好)，而空(5)处应填M。


### 第2题
阅读以下说明和C代码，填补C代码中的空缺，将解答写在答题纸的对应栏内。

**【说明】**
![](https://raw.githubusercontent.com/xzMhehe/StaticFile_CDN/main/static/img/mo/20231012131447.png)

**【C代码】**
![](https://raw.githubusercontent.com/xzMhehe/StaticFile_CDN/main/static/img/mo/20231012131511.png)


**试题难度**：一般

**知识点**：C程序设计>C程序设计

**试题答案**：
>(1) fabs(x)<=1e-6 或fabs(x)<=0.00001x==0.0或等效形式
(2) x2
(3) x/(x1*x1)或等效形式
(4) (x2-x1)/x1或等效形式
(5) x+=0.1或x=x+0.1或等效形式

本题考查C程序基本运算和流程控制的应用。

函数cubeRoot(x)根据给定的公式计算x的立方根。

根据精度要求，绝对值小于1e-6的数，其立方根为0，因此，空(1)处应填入“fabs(x)<=1e-6”或其等效形式。

分析函数cubeRoot中的代码，可知x1对应公式中的xn，x2对应公式中的xn+1，每次循环时，需要将x2传给x1，再计算出新的x2，因此空(2)处应填入“x2”，空(3)处应填入“x/(x1*x1)”。在满足精度要求时结束循环，即空(4)处应填入“(x2-x1)/x1 ”。

根据题干部分的说明，显然空(5) 处应填入“x+=0.1”或其等效形式。

### 第3题
阅读以下说明和C代码，填补C代码中的空缺，将解答写在答题纸的对应栏内。

【说明】

下面程序中，函数convertion(char *p)的功能是通过调用本程序中定义的函数，将p所指示字符串中的字母和数字字符按如下约定处理：
（1）大写字母转换为小写字母；

（2）小写字母转换为大写字母；

（3）数字字符转换为其伙伴字符（当两个十进制数字相加为9时，这两个十进制数字对应的数字字符互为伙伴字符）。例如，字符'2'的伙伴字符为'7'、'8'的伙伴字符为'1'、'0'的伙伴字符为'9'等。

【C代码】

![](https://raw.githubusercontent.com/xzMhehe/StaticFile_CDN/main/static/img/mo/20231012131632.png)

**试题难度**：一般

**知识点**：C程序设计>C程序设计

**试题答案**：
>(1) *c-'0'或c\[0\]-'0'或*c-48或c\[0\]-48或等效形式
(2) isUpper(*p)或isUpper(p[0])
(3) isLower(*p)或isLower(p[0])
(4) isDigit(*p) 或isDigit(p[0])
(5) p++或++p或p=p+1或p+=1或等效形式


观察代码中定义的函数，isUpper(char c)、isLower(char c)、isDigit(char c)的形参为传值方式的字符型参数，调用这些函数时实参为字符变量或常量。toUpper(char *c)、toLower(char *c)、cDigit(char *c)、convertion(char *p)的形参为字符指针类型，调用这些函数时实参应为指向字符的指针(字符变量的地址)。

根据题干部分的描述，求解数字字符的伙伴字符时，需要进行算术运算，用9减去数字字符对应的数值(即数字字符- '0')，得到的值再加上'0'从而再次转换为数字字符，因此空(1)处应填入“*c-'0'” 或其等效形式。

函数convertion(char \*p)根据题干描述的要求对字符进行转换，满足空(2)所给的条件时需要调用toLower(p)将字符转换为小写字母，因此空(2)处应判断字符是否为大写字母，应填入“isUpper(\*p)"或其等效形式；满足空(3)所给的条件时需要调用toUpper(p)将字符转换为大写字母，因此空(3)处应判断字符是否为小写字母，应填入“isLower(\*p)"或其等效形式;满足空(4)所给的条件时需要调用cDigit(p)将数字字符转换为其伙伴字符，因此空(4)处应判断字符是否为数字字符，应填入“isDigit(*p)”或其等效形式。

在while循环中还需要对指针变量p进行递增，处理完p指向的当前字符后再指向下一字符，因此空(5)处应填入“p++”或其等效形式。

### 第 4 题
阅读以下说明和C代码，填补C代码中的空缺，将解答写在答题纸的对应栏内。

**【说明】**

函数createList(int a[ ],int n)根据数组a的前n个元素创建对应的单循环链表，并返回链表的尾结点指针。例如，根据数组int a[] = {25,12,39}创建的单循环链表如图4-1所示。

![](https://raw.githubusercontent.com/xzMhehe/StaticFile_CDN/main/static/img/mo/20231012131932.png)

函数display(NodePtr tail)的功能是从表头元素开始，依次输出单循环链表中结点数据域的值。
链表的结点类型定义如下：

![](https://raw.githubusercontent.com/xzMhehe/StaticFile_CDN/main/static/img/mo/20231012131958.png)

**【C代码】**
![](https://raw.githubusercontent.com/xzMhehe/StaticFile_CDN/main/static/img/mo/20231012132247.png)


**试题难度**：一般

**知识点**：C程序设计>C程序设计

**试题答案**：
>(1) tail
(2) p->key或(*p).key或等效形式
(3) p->next或(*p).next或等效形式
(4) !tail或tail==NULL或等效形式
(5) p->next 或(*p).next或等效形式

本题考查C程序流程控制和指针的应用。

函数createList()中首先创造链表的第一个结点，然后通过循环来创建其余的n-1个结点。显然，创建第一个结点后，该结点是表尾结点，因此空(1)处应填入“tail"，来设置表尾指针。通过运算p->next=p，形成只有1个结点的单循环链表，如下图所示。

![](https://raw.githubusercontent.com/xzMhehe/StaticFile_CDN/main/static/img/mo/20231012132322.png)

对于for循环中创建的每一个结点(p所指)，首先通过运算p->key = a[i]设置其数据域的值，因此空(2)处应填入“p->key”或其等效形式，如下图(a)所示，然后设置新结点的指针域(p->next)，使其指向第一个结点(tail->next所指)，即p->next = tail->next，如下图(b)所示，再将结点链接进入链表，即tail>-next=p，如下图(c)所示，最后更新表尾指针，即tail=p。因此空(3) 处应填入“p->next"。

![](https://raw.githubusercontent.com/xzMhehe/StaticFile_CDN/main/static/img/mo/20231012132416.png)

### 第 5 题
阅读以下说明和Java代码，填写Java代码中的空缺，将解答写入答题纸的对应栏内。

**【说明】**

在线购物系统需提供订单打印功能，相关类及关系如图5-1所示，其中类Order能够完成打印订单内容的功能，类HeadDecorator与FootDecorator分别完成打印订单的抬头和脚注的功能。

![](https://raw.githubusercontent.com/xzMhehe/StaticFile_CDN/main/static/img/mo/20231012132451.png)

**【Java代码】**
![](https://raw.githubusercontent.com/xzMhehe/StaticFile_CDN/main/static/img/mo/20231012132522.png)

**试题难度**：一般

**知识点**：Java程序设计>Java程序设计案例

**试题答案：**
>(1) extends
(2) this.order
(3) super(order)
(4) super(order)
(5) super.printOrder()
(6) extends
(7) this.order


### 第 6 题
阅读下列说明和C++代码，填写C++代码中的空缺，将解答写入答题纸的对应栏内。

**【说明 】**

在线购物系统需提供订单打印功能，相关类及关系如图6-1所示，其中类Order能够完成打印订单内容的功能，类HeadDecorator与FootDecorator分别完成打印订单的抬头和脚注的功能。

![](https://raw.githubusercontent.com/xzMhehe/StaticFile_CDN/main/static/img/mo/20231012132632.png)

下面的C++代码应实现上述设计，其执行结果如下：

![](https://raw.githubusercontent.com/xzMhehe/StaticFile_CDN/main/static/img/mo/20231012132658.png)

**【C++代码】**
![](https://raw.githubusercontent.com/xzMhehe/StaticFile_CDN/main/static/img/mo/20231012132721.png)


**试题难度**：一般
**知识点**：C++程序设计>C++程序设计
**试题答案**：
>(1) : public Order
(2) this->order 或(*this).order
(3) Decorator(order)
(4) Decorator(order)
(5) Decorator:printOrder()
(6) :public Order
(7) this->order 或(*this).order



本题考查C++语言程序设计的能力，涉及类、对象、函数的定义和相关操作。要求考生根据给出的案例和代码说明，阅读并完成程序填空。
本题目中涉及打印订单内容、打印抬头和打印脚注。根据说明进行设计，题目给出了类图(图6-1类图所示)。

图中类Order有PrintOrder和Decorator两个子类。Decorator与Order之间为聚合关系。Decorator有两个子类HeadDecorator和FootDecorator，分别实现打印抬头和打印脚注的功能。C++语言中，子类继承父类使用冒号(:)加父类实现。Order类中定义虚函数virtual voidprintOrder()方法，实现打印“订单内容”。Decorator中定义私有Order成员，即：

![](https://raw.githubusercontent.com/xzMhehe/StaticFile_CDN/main/static/img/mo/20231012132810.png)

并且定义带参数构造器：

![](https://raw.githubusercontent.com/xzMhehe/StaticFile_CDN/main/static/img/mo/20231012132837.png)

其中对order进行初始化。
C++中，一个类有显式定义带参数构造器时，编译器就不会自动生成缺省的构造器，而子类构造器中首先调用父类的构造器，缺省的情况下调用父类的缺省不带参数构造器，带参数构造器需要显式调用，形式为冒号(:)加上父类的带参数构造器。对象的属性若为引用类型，自动初始化为NULL，所以需要在构造器中对order加以显式初始化。其构造器接收order，参数名称与对象的属性名均为order，需要用this关键字来引用当前对象或类实例，可以用this->或(this).取属性或行为，即：

![](https://raw.githubusercontent.com/xzMhehe/StaticFile_CDN/main/static/img/mo/20231012132918.png)

Decorator覆盖父类的printOrder()方法。在printOrder()方法中，实现order不为空引用时，采用order->printOrder()调用Order的printOrder()方法，实现打印“订单内容”；而若order为空时，则不进行调用，即没有打印订单内容。

HeadDecorator类和FootDecorator类中均定义带Order类型的参数的构造器。在C++中，构造器中自动调用父类的缺省无参数构造器，而Decorator中只定义了带参数构造器，因此，需要显式调用父类Decorator中的带参数构造器，形式为：构造器名(参数)，即Decorator(order)，对Decorator中私有成员order进行初始化。

HeadDecorator覆盖父类的printOrder()方法。在printOrder()方法中，先打印“订单抬头”，再使用Decorator::printOrder()调用父类的printOrder()方法打印“订单内容”。FootDecorator覆盖父类的printOrder()方法。在printOrder()方法中，先使用Decorator::printOrder()调用父类的printOrder()方法打印“订单内容”，再打印“订单脚注”。

在PrintOrder类中，实现整体订单的打印逻辑。其中定义Order属性变量order，构造器PrintOrder(Order order)中对order进行初始化，因为参数名称也是order， 所以需要采用this->order或(this).order区分对象的属性。在printOrder()方法中，实现的主要逻辑为打印“订单内容”的基础上，加上打印“订单抬头”和“订单脚注”。此时，order对象不为NULL时只可以打印“订单内容”，再执行如下语句：

![](https://raw.githubusercontent.com/xzMhehe/StaticFile_CDN/main/static/img/mo/20231012133000.png)

实现在打印“订单内容”的基础上，加上打印“订单抬头”，再执行如下语句：

![](https://raw.githubusercontent.com/xzMhehe/StaticFile_CDN/main/static/img/mo/20231012133016.png)

实现在打印“订单内容”和“订单抬头”的基础上，加上打印“订单脚注”。此时，head->printOrder()调用执行printOrder()方法即可打印出：
>“订单抬头”
“订单内容”
“订单脚注”

若order对象为NULL时，则只打印出“订单抬头”和“订单脚注”。

入口函数main()中，先用new关键字创建Order类的对象，即对象指针order，并作为参数传递给PrintOrder的构造器进行创建PrintOrder对象，即对象指针print，之后print->printOrder()即调用PrintOrder中的printOrder()方法，执行主要打印逻辑。即：

![](https://raw.githubusercontent.com/xzMhehe/StaticFile_CDN/main/static/img/mo/20231012133046.png)

综上所述，空(1)和空(6)表示继承Order类，即：public Order；空(2)需要表示Decorator对象的order属性，即this->order或(*this).order；空(3)和空(4)需要显式调用父类Decorator的带参数构造器，参数为order，即Decorator(order)；空(5) 处调用父类对象的printOrder()方法，即

Decorator::printOrder()；空(7)需要表示PrintOrder对象的order属性，即this->order或(*this).order。