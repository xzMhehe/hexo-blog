---
title: Java-OOP面试打卡第一天
date: 2021-06-27 10:00:18
tags:
  - Java
  - 面经
categories:
  - Java
keywords:
  - Java
description: Java
headimg: https://cdn.jsdelivr.net/gh/xzMhehe/StaticFile_CDN/static/img/20210628111242.png

thumbnail: https://cdn.jsdelivr.net/gh/xzMhehe/StaticFile_CDN/static/img/20210628111242.png
---


# 1、什么是B/S架构？什么是C/S架构
1. B/S(Browser/Server)， `浏览器`/`服务器程序`

2. C/S(Client/Server)，`客户端`/`服务端`，`桌面应用程序`


# 2、Java都有那些开发平台？
1. JAVA SE：主要用在客户端开发

2. JAVA EE：主要用在web应用程序开发

3. JAVA ME：主要用在嵌入式应用程序开发

# 3、什么是JDK？什么是JRE?
1. JDK：java development kit：java开发工具包，是`开发人员所需要安装的环境`

2. JRE：java runtime environment：java运行环境，`java程序运行所需要安装的环境`


# 4、Java语言有哪些特点
1. 简单易学、有丰富的类库

2. 面向对象（Java最重要的特性，让程序耦合度更低，内聚性更高）

3. 与平台无关性（JVM是Java跨平台使用的根本）

4. 可靠安全

5. 支持多线程


# 5、面向对象和面向过程的区别
1. 面向过程： 一种较早的编程思想，顾名思义就是该思想是站着过程的角度思考问题，强调的就是功能行为，`功能的执行过程`，即`先后顺序`，而每一个功能我们都使用函数（类似于方法）把这些步骤一步一步实现。使用的时候依次调用函数就可以了。 

2. 面向对象： 一种基于面向过程的新编程思想，顾名思义就是该思想是`站在对象的角度`思考问题， 我们把多个功能合理放到不同对象里，强调的是具备某些功能的对象。 具备某种功能的实体，称为对象。面向对象最小的程序单元是：类。面向对象更加符合常规的思维 方式，稳定性好，可重用性强，易于开发大型软件产品，有良好的可维护性。 在软件工程上，面向对象可以使工程`更加模块化`，`实现更低的耦合`和`更高的内聚`。


# 6、什么是数据结构？
计算机保存，组织数据的方式


# 7、Java的数据结构有那些？
1. `线性表（ArrayList）` 
 
2. `链表（LinkedList）`

3. `栈（Stack）` 
 
4. `队列（Queue）`

5. `图（Map）`

6. `树（Tree）`


# 8、什么是OOP?
面向对象编程


# 9、类与对象的关系?
`类是对象的抽象`，`对象是类的具体`，`类是对象的模板`，`对象是类的实例`

# 10、Java中有几种数据类型
`整形`：byte,short,int,long

`浮点型`：ﬂoat,double 

`字符型`：char

`布尔型`：boolean


# 11、标识符的命名规则。
1. 标识符的含义：
是指在程序中，我们自己定义的内容，譬如，类的名字，方法名称以及变量名称等等，都是标识符。

2. 命名规则：（硬性要求） 标识符可以包含英文字母，0-9的数字，$以及_ 标识符不能以数字开头, 标识符不是关键字

3. 命名规范：（非硬性要求） 
    - 类名规范：首字符大写，后面每个单词首字母大写（大驼峰式）
    - 变量名规范：首字母小写，后面每个单词首字母大写（小驼峰式） 
    - 方法名规范：同变量名。


# 12、instanceof关键字的作用
`instanceof` 严格来说是Java中的一个`双目运算符`，`用来测试一个对象是否为一个类的实例`，用法为：

`boolean result = obj instanceof Class`

其中 obj 为一个对象，Class 表示一个类或者一个接口，当 obj 为 Class 的对象，或者是其直接或 间接子类，或者是其接口的实现类，结果result 都返回 true，否则返回false。 

注意：编译器会检查 obj 是否能转换成右边的class类型，如果不能转换则直接报错，如果不能确定类型，则通过编译，具体看运行时定。


# 13、什么是隐式转换，什么是显式转换
显示转换就是类型强转，把一个大类型的数据强制赋值给小类型的数据；

隐式转换就是大范围的变量能 够接受小范围的数据；隐式转换和显式转换其实就是自动类型转换和强制类型转换。


# 14、Char类型能不能转成int类型？能不能转化成string类型，能不 能转成double类型
Char在java中也是比较特殊的类型，它的int值从1开始，一共有2的16次方个数据； 

`Char<int<long<ﬂoat<double`；

Char类型可以隐式转成int,double类型，但是不能隐式转换成 string；

如果char类 型转成byte，short类型的时候，需要强转。


# 15、什么是拆装箱？
装箱就是自动将基本数据类型转换为包装器类型（int-->Integer）；调用方法：Integer的 `valueOf(int)` 方法

拆箱就是自动将包装器类型转换为基本数据类型（Integer-->int）。调用方法：Integer的intValue 方法

在`Java SE5`之前，如果要生成一个数值为10的Integer对象，必须这样进行：

`Integer i = new Integer(10);`

而在从Java SE5开始就提供了自动装箱的特性，如果要生成一个数值为10的Integer对象，只需要 这

样就可以了：
`Integer i = 10;`


# 16、Java中的包装类都是那些？
byte：Byte，short：Short，int：Integer，long：Long，ﬂoat：Float，double：Double，char： Character ，boolean：Boolean


# 17、一个java类中包含那些内容？
属性、方法、内部类、构造方法、代码块。


# 18、那针对浮点型数据运算出现的误差的问题，你怎么解决？
使用Bigdecimal类进行浮点型数据的运算


# 19、面向对象的特征有哪些方面?
**抽象**:             
抽象是将一类对象的共同特征总结出来构造类的过程, 包括数据抽象和行为抽象两方面。抽象只关注对 象有哪些属 性和行为,并不关注这些行为的细节是什么。 

**继承**:               
继承是从已有类得到继承信息创建新类的过程.提供继承信息的类被称为父类(超类、基类) ;得到继承信 息的类被称 为子类(派生类)。继承让变化中的软件系统有了一定的延续性 ,同时继承也是封装程序中可变因素的重要 手段(如果 不能理解请阅读阎宏博土的《Java 与模式》或《设计模式精解》中.关于桥梁模式的部分)。 

**封装**：
通常认为封装是把数据和操作数据的方法绑定起来，对数据的访问 只能通过已定义的接口。面向对象的本质就是将现实世界描绘成一系列完全自 治、封闭的对象。我们在类中编写的方法就是对实现细节的一种封装；我们编写 一个类就是对数据和数据操作的封装。可以说，封装就是隐藏一切可隐藏的东西， 只向外界提供最简单的编程接口（可以想想普通洗衣机和全自动洗衣机的差别， 明显全自动洗衣机封装更好因此操作起来更简单；我们现在使用的智能手机也是 封装得足够好的，因为几个按键就搞定了所有的事情）。

**多态性**：                   
多态性是指允许不同子类型的对象对同一消息作出不同的响应。 简单的说就是用同样的对象引用调用同样的方法但是做了不同的事情。多态性分 为编译时的多态性和运行时的多态性。如果将对象的方法视为对象向外界提供的 服务，那么运行时的多态性可以解释为：当 A 系统访问 B 系统提供的服务时，B 系统有多种提供服务的方式，但一切对 A 系统来说都是透明的（就像电动剃须 刀是 A 系统，它的供电系统是 B 系统，B 系统可以使用电池供电或者用交流电， 甚至还有可能是太阳能，A 系统只会通过 B 类对象调用供电的方法，但并不知道 供电系统的底层实现是什么，究竟通过何种方式获得了动力）。

方法重载 （overload）实现的是编译时的多态性（也称为前绑定），而方法重写（override） 实现的是运行时的多态性（也称为后绑定）。运行时的多态是面向对象最精髓的 东西.

要`实现多态`需要做两件事：                
1). 方法重写（子类继承父类并重写父类中已 有的或抽象的方法）；       
2). 对象造型（用父类型引用引用子类型对象，这样同样 的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。

# 20、访问修饰符 public,private,protected,以及不写（默认） 时的 区别？
类的成员不写访问修饰时默认为 default。默认对于同一个包中的其他类相当于公 开（public），对于 不是同一个包中的其他类相当于私有（private）。受保护 （protected）对子类相当于公开，对不是同 一包中的没有父子关系的类相当于私 有。Java 中，外部类的修饰符只能是 public 或默认，类的成员 （包括内部类）的 修饰符可以是以上四种。


# 21、String 是最基本的数据类型吗？
`不是`。Java 中的基本数据类型只有 `8` 个：`byte`、`short`、`int`、`long`、`ﬂoat`、`double`、 `char`、 `boolean`；

除了基本类型（primitive type），剩下的都是`引用类型`（reference type），Java 5 以后引 入的`枚举类型`也算是一种`比较特殊`的引用类型。


# 22、ﬂoat f=3.4;是否正确？

答:`不正确`。3.4 是`双精度数`，将双精度型（double）赋值给浮点型（ﬂoat）属于 下转型（downcasting，也称为窄化）会造成精度损失，因此需要强制类型转换 ﬂoat f =(ﬂoat)3.4; 或者写成 ﬂoat f =`3.4F`;。

# 23、short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1; 有错 吗？
对于 short s1 = 1; s1 = s1 + 1;

由于 1 是 int 类型，因此 s1+1 运算结果也是 int 型，需要强制转换类型 才能赋值给 short 型。

而 short s1 = 1; s1 += 1;可以正确 编译，因为 s1+= 1;相当于 s1 = (short)(s1 + 1);其中有隐含的强制类型转换。

# 24、重载和重写的区别

**重写(Override)**
从字面上看，重写就是 重新写一遍的意思。其实就是在`子类`中`把父类本身有的方法重新写一遍`。子类继承了父类
原有的方法，但有时子类并不想原封不动的继承父类中的某个方法，所以在方法名，参数列表，返回类 型(除过子
类中方法的返回值是父类中方法返回值的子类时)都相同的情况下， 对方法体进行修改或重写，这就是 重写。但要

注意子类函数的`访问修饰权限不能少于父类的`。

重写 总结：         
1. 发生在父类与子类之间

2. 方法名，参数列表，返回类型（除过子类中方法的返回类型是父类中返回类型的子类）必须相同

3. 访问修饰符的限制一定要大于被重写方法的访问修饰符（public>protected>default>private)

4. 重写方法一定不能抛出新的检查异常或者比被重写方法申明更加宽泛的检查型异常


**重载（Overload）**             
在一个类中，`同名`的`方法`如果有`不同的参数列表`（参数类型不同、参数个数不同甚至是参数顺序不同） 则视为重载。同时，重载对返回类型没有要求，可以相同也可以不同，但不能通过返回类型是否相同来 判断重载。

重载总结：
1. 重载Overload是一个类中多态性的一种表现

2. 重载要求同名方法的参数列表不同(参数类型，参数个数甚至是参数顺序)

3. 重载的时候，返回值类型可以相同也可以不相同。无法以返回型别作为重载函数的区分标准
（原因就是：编译器在编译时，不会去判断函数的返回类型！也就是说你返回类型虽然不同，但是只有函数调用以后，编译器才去验证返回类型。）


# 25、equals与==的区别

**==**：             
== 比较的是变量(栈)内存中存放的对象的(堆)内存地址，用来判断两个对象的地址是否相同，即是否是 指相同一个对象。比较的是真正意义上的指针操作。 1、比较的是操作符两端的操作数是否是同一个对象。 2、两边的操作数必须是同一类型的（可以是父子类之间）才能编译通过。 3、比较的是地址，如果是具体的阿拉伯数字的比较，值相等则为true，如： int a=10 与 long b=10L 与 double c=10.0都是相同的（为true），因为他们都指向地址为10的堆。

**equals**：               
equals用来比较的是两个对象的内容是否相等，由于所有的类都是继承自java.lang.Object类的，所以 适用于所有对象，如果没有对该方法进行覆盖的话，调用的仍然是Object类中的方法，而Object中的 equals方法返回的却是==的判断。

**总结**：            
所有比较是否相等时，都是用equals 并且在对常量相比较时，把`常量写在前面`，因为使用object的 equals object可能为null 则空指针 在阿里的代码规范中只使用 equals ，阿里插件默认会识别，并可以快速修改，推荐安装阿里插件来排 查老代码使用“==”，替换成equals

# 26、++i与i++的区别

i++：先赋值，后计算 ++i：先计算，后赋值

# 27、程序的结构有那些？

`顺序结构`、 `选择结构`、 `循环结构`

# 28、数组实例化有几种方式？
静态实例化：创建数组的时候已经指定数组中的元素,

`int [] a= new int[]{ 1 , 3 , 3}`

动态实例化：实例化数组的时候，只指定了数组程度，数组中所有元素都是数组类型的默认值

# 29、Java中各种数据默认值

Byte,short,int,long默认是都是0 

Boolean默认值是false 

Char类型的默认值是''

Float与double类型的默认是0.0 对象类型的默认值是null

# 30、Java常用包有那些？

Java.lang 

Java.io 

Java.sql 

Java.util

Java.awt 

Java.net 

Java.math

# 31、Object类常用方法有那些？

Equals Hashcode toString wait notify clone getClass

# 32、java中有没有指针？

有指针，但是隐藏了，开发人员无法直接操作指针，由jvm来操作指针

# 33、java中是值传递引用传递？
`理论上说`，`java都是引用传递`，对于基本数据类型，传递是值的`副本`，而不是值本身。对于对象类型， `传递是对象的引用`，当在一个方法操作操作参数的时候，`其实操作的是引用所指向的对象`。


# 34、实例化数组后，能不能改变数组长度呢？

不能，数组一旦实例化，它的长度就是固定的

# 35、假设数组内有5个元素，如果对数组进行反序，该如何做？

创建一个新数组，从后到前循环遍历每个元素，将取出的元素依次顺序放入新数组中

# 36、形参与实参区别

**实参(argument)**：           
全称为"实际参数"是在调用时传递给函数的参数. 实参可以是常量、变量、表达式、函数等， 无论实参

是何种类型的量，在进行函数调用时，它们都必须具有确定的值， 以便把这些值传送给形参。 因此应 预先用赋值，输入等办法使实参获得确定值。

**形参(parameter)**：           
全称为"形式参数" 由于它不是实际存在变量，所以又称虚拟变量。是在定义函数名和函数体的时候使用 的参数,目的是用来接收调用该函数时传入的参数.在调用函数时，实参将赋值给形参。因而，必须注意 实参的个数，类型应与形参一一对应，并且实参必须要有确定的值。

形参出现在函数定义中，在整个函数体内都可以使用， 离开该函数则不能使用。

实参出现在主调函数中，进入被调函数后，实参变量也不能使用。

形参和实参的功能是作数据传送。发生函数调用时， 主调函数把实参的值传送给被调函数的形参从而实 现主调函数向被调函数的数据传送。

**总结**
1. `形参变量只有在被调用时才分配内存单元`，`在调用结束时`， `即刻释放所分配的内存单元`。`因此，形参 只有在函数内部有效`。 函数调用结束返回

主调函数后则不能再使用该形参变量。

2. 实参可以是常量、变量、表达式、函数等， 无论实参是何种类型的量，在进行函数调用时，它们都必 须具有确定的值， 以便把这些值传送给形

参。 因此应预先用赋值，输入等办法使实参获得确定值。

3. 实参和形参在数量上，类型上，顺序上应严格一致， 否则会发生“类型不匹配”的错误。 4.函数调用中发生的数据传送是单向的。 即只能把实参的值传送给形参，而不能把形参的值反向地传送 给实参。 因此在函数调用过程中，形参的值

发生改变，而实参中的值不会变化。

5. 当形参和实参不是指针类型时，在该函数运行时，形参和实参是不同的变量，他们在内存中位于不同 的位置，形参将实参的内容复制一份，在该 函数运行结束的时候形参被释放，而实参内容不会改变。 而如果函数的参数是指针类型变量,在调用该函数的过程中，传给函数的是实参的地址，在函数体内部使 用的也是实参的地址，即使用的就是实参 本身。所以在函数体内部可以改变实参的值。


# 37、构造方法能不能显式调用？
不能，构造方法当成普通方法调用，只有在创建对象的时候它才会被系统调用


# 38、什么是方法重载？
方法的重载就是在同一个类中允许同时存在一个以上的同名方法，只要它们的参数个数或者类型不同即 可。在这种情况下，该方法就叫被重载了，这个过程称为方法的重载（override）


# 39、构造方法能不能重写？能不能重载？
可以重载，但不能重写。


# 40、内部类与静态内部类的区别？
`静态内部类相对与外部类是独立存在的`，·在`静态内部类`中`无直接访问`外部类中`变量`、`方法`。 如果要访问的话，`必须要new`一个外部类的`对象`，使用new出来的对象来访问。但是`可以直接访问静态的变量`、 `调用静态的方法`；

普通内部类`作为外部类一个成员而存在`，在`普通内部类中`可以`直接访问外部类属性`，`调用外部类的方法`。

如果外部类要访问内部类的属性或者调用内部类的方法，必须要创建一个内部类的对象，使用该对象访 问属性或者调用方法。

如果其他的类要访问普通内部类的属性或者调用普通内部类的方法，必须要在外部类中创建一个普通内 部类的对象作为一个属性，外同类可以通过该属性调用普通内部类的方法或者访问普通内部类的属性

如果其他的类要访问静态内部类的属性或者调用静态内部类的方法，直接创建一个静态内部类对象即可。


# 41、Static关键字有什么作用？
Static可以修饰内部类、方法、变量、代码块 Static修饰的类是静态内部类 Static修饰的方法是静态方法，表示该方法属于当前类的，而不属于某个对象的，静态方法也不能被重 写，可以直接使用类名来调用。在static方法中不能使用this或者super关键字。

Static修饰变量是静态变量或者叫类变量，静态变量被所有实例所共享，不会依赖于对象。静态变量在 内存中只有一份拷贝，在JVM加载类的时候，只为静态分配一次内存。

Static修饰的代码块叫静态代码块，通常用来做程序优化的。静态代码块中的代码在整个类加载的时候 只会执行一次。静态代码块可以有多个，如果有多个，按照先后顺序依次执行。


# 42、ﬁnal在java中的作用，有哪些用法?
ﬁnal也是很多面试喜欢问的地方,但我觉得这个问题很无聊,通常能回答下以下5点就不错了:

1. 被ﬁnal修饰的类不可以被继承

2. 被ﬁnal修饰的方法不可以被重写

3. 被ﬁnal修饰的变量不可以被改变.如果修饰引用,那么表示引用不可变,引用指向的内容可变.

4. 被ﬁnal修饰的方法,JVM会尝试将其内联,以提高运行效率

5. 被ﬁnal修饰的常量,`在编译阶段会存入常量池中`.

除此之外,编译器对ﬁnal域要遵守的两个重排序规则更好:

在构造函数内对一个ﬁﬁnal域的写入,与随后把这个被构造对象的引用赋值给一个引用变量,这两个操作之 间不能重排序

初次读一个包含ﬁnal域的对象的引用,与随后初次读这个ﬁnal域,这两个操作之间不能重排序


# 43、StringString StringBuﬀﬀer 和 StringBuilder 的区别是什么？
`String是只读字符串`，它并不是基本数据类型，而是一个对象。 从底层源码来看是一个`ﬁnal`类型的`字符数组`，所引用的字符串不能被改变，一经定义，无法再增删改。每次对String的操作都会生成新的

String对象

`private final char value[];`

每次 + 操作 ： 隐式在堆上new了一个跟原字符串相同的StringBuilder对象，再调用append方法拼接 + 后面的字符。

StringBuﬀer与StringBuilder都继承了AbstractStringBulder类，而AbtractStringBuilder又实现了 CharSequence接口，两个类都是用来进行字符串操作的。

`在做字符串拼接修改删除替换时`，`效率比string更高`。

`StringBuffer是线程安全的`，`Stringbuilder是非线程安全的`。所以Stringbuilder比stringbuffer效率更 高，StringBuffer的方法大多都加了synchronized关键字


# 44、String str=”aaa”,与String str=new String(“aaa”)一样吗？ 
`String a = "aaa";`          
用这种方式的时候java首先在内存中寻找"aaa"字符串，如果有，就把aaa的地址给它          
如果没有则创建          
`String a = new String("aaa");`
是不管内存中有没有"aaa"            
都开辟一块新内存保存它          
可以用以下方法验证下          
```java
String a = "aaa";
String b = "aaa";
String c = new String("aaa");
System.out.println(a==b);
System.out.println(a==c);
```
结果应该是：
```bash
true
false
```


# 45、讲下java中的math类有那些常用方法？
Pow()：幂运算 

Sqrt()：平方根 

Round()：四舍五入 

Abs()：求绝对值 

Random()：生成一个0-1的随机 数，包括0不包括1


# 46、String类的常用方法有那些？
charAt：返回指定索引处的字符 

indexOf()：返回指定字符的索引 

replace()：字符串替换 

trim()：去除字符串两端空白 

split()：分割字符串，返回一个分割后的字符串数组 

getBytes()：返回字符串的byte类 型数组 

length()：返回字符串长度 

toLowerCase()：将字符串转成小写字母 

toUpperCase()：将字符串 转成大写字符 

substring()：截取字符串 

format()：格式化字符串 equals()：字符串比较


# 47、Java中的继承是单继承还是多继承
Java中既有单继承，又有多继承（实现多个接口）。对于java类来说只能有一个父类，对于接口来说可以同时`实现`多个接 口


# 48、Super与this表示什么？
Super表示当前类的父类对象 This表示当前类的对象


# 49、普通类与抽象类有什么区别？
普通类不能包含抽象方法，抽象类可以包含抽象方法 抽象类不能直接实例化，普通类可以直接实例化


# 50、什么是接口？为什么需要接口？
接口就是某个事物对外提供的一些功能的声明，是一种特殊的java类，接口弥补了java单继承的缺点


# 51、接口有什么特点？
接口中声明全是public static final修饰的常量 接口中所有方法都是抽象方法 接口是没有构造方法的 接口也不能直接实例化 接口可以多继承


# 52、抽象类和接口的区别?
**抽象类**：            
1. 抽象方法，只有行为的概念，没有具体的行为实现。使用abstract关键字修饰，没有方法体。子类 必须重写这些抽象方法。 

2. 包含抽象方法的类，一定是抽象类。

3. 抽象类只能被继承，一个类只能继承一个抽象类。

**接口**：        
1. 全部的方法都是抽象方法，属性都是常量

2. 不能实例化，可以定义变量。

3. 接口变量可以引用具体实现类的实例

4. 接口只能被实现，一个具体类实现接口，必须实现全部的抽象方法

5. 接口之间可以多实现

6. 一个具体类可以实现多个接口，实现多继承现象

